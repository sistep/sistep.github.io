<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Idea快捷键]]></title>
      <url>/2018/05/13/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/13/Idea快捷键/%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg" alt="IDEA快捷键"></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记]]></title>
      <url>/2017/12/11/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1>常用模块</h1>
<h2 id="numpy">numpy</h2>
<ul>
<li><strong>将数组保存到文件、读取</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.savetxt(filename,X)</span><br><span class="line">X=np.loadtxt(filename)</span><br></pre></td></tr></table></figure>
<h2 id="logging">logging</h2>
<p>转自<a href="http://blog.csdn.net/zyz511919766/article/details/25136485/" target="_blank" rel="noopener">Python logging模块详解</a></p>
<p>简单将日志打印到屏幕：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)  </span><br><span class="line">logging.info(<span class="string">'info message'</span>)  </span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)  </span><br><span class="line">logging.error(<span class="string">'error message'</span>)  </span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)  </span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">WARNING:root:warning message</span><br><span class="line">ERROR:root:error message</span><br><span class="line">CRITICAL:root:critical message</span><br></pre></td></tr></table></figure>
<p>可见，默认情况下python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p>灵活配置日志级别，日志格式，输出位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG,  </span><br><span class="line">                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,  </span><br><span class="line">                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,  </span><br><span class="line">                    filename=<span class="string">'/tmp/test.log'</span>,  </span><br><span class="line">                    filemode=<span class="string">'w'</span>)  </span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)  </span><br><span class="line">logging.info(<span class="string">'info message'</span>)  </span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)  </span><br><span class="line">logging.error(<span class="string">'error message'</span>)  </span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)  </span><br><span class="line"></span><br><span class="line">查看输出：</span><br><span class="line">cat /tmp/test.log</span><br><span class="line">Mon, <span class="number">05</span> May <span class="number">2014</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">53</span> test_logging.py[line:<span class="number">9</span>] DEBUG debug message</span><br><span class="line">Mon, <span class="number">05</span> May <span class="number">2014</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">53</span> test_logging.py[line:<span class="number">10</span>] INFO info message</span><br><span class="line">Mon, <span class="number">05</span> May <span class="number">2014</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">53</span> test_logging.py[line:<span class="number">11</span>] WARNING warning message</span><br><span class="line">Mon, <span class="number">05</span> May <span class="number">2014</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">53</span> test_logging.py[line:<span class="number">12</span>] ERROR error message</span><br><span class="line">Mon, <span class="number">05</span> May <span class="number">2014</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">53</span> test_logging.py[line:<span class="number">13</span>] CRITICAL critical message</span><br></pre></td></tr></table></figure>
<p>可见在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有<br>
filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。<br>
filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。<br>
format：指定handler使用的日志显示格式。<br>
datefmt：指定日期时间格式。<br>
level：设置rootlogger（后边会讲解具体概念）的日志级别<br>
stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p>
<p>format参数中可能用到的格式化串：<br>
%(name)s Logger的名字<br>
%(levelno)s 数字形式的日志级别<br>
%(levelname)s 文本形式的日志级别<br>
%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有<br>
%(filename)s 调用日志输出函数的模块的文件名<br>
%(module)s 调用日志输出函数的模块名<br>
%(funcName)s 调用日志输出函数的函数名<br>
%(lineno)d 调用日志输出函数的语句所在的代码行<br>
%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示<br>
%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数<br>
%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒<br>
%(thread)d 线程ID。可能没有<br>
%(threadName)s 线程名。可能没有<br>
%(process)d 进程ID。可能没有<br>
%(message)s用户输出的消息</p>
<h3 id="输出到屏幕同时存入文件">输出到屏幕同时存入文件</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">ISOTIMEFORMAT=<span class="string">'%m-%d_%H-%M'</span></span><br><span class="line">logger=logging.getLogger()</span><br><span class="line">log_file=gl.LOG_PATH+<span class="string">'SCNN-'</span>+time.strftime(ISOTIMEFORMAT,time.localtime())+<span class="string">'.log'</span></span><br><span class="line">log_fh=logging.FileHandler(log_file)</span><br><span class="line">log_ch=logging.StreamHandler()</span><br><span class="line">log_formatter=logging.Formatter(<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>)</span><br><span class="line">log_fh.setFormatter(log_formatter)</span><br><span class="line">log_ch.setFormatter(log_formatter)</span><br><span class="line">logger.addHandler(log_fh)</span><br><span class="line">logger.addHandler(log_ch)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br></pre></td></tr></table></figure>
<h1>《Python核心编程》笔记</h1>
<h2 id="安装配置">安装配置</h2>
<ol>
<li>启动Eclipse, 点击Help-&gt;Install New Software…   在弹出的对话框中，点Add 按钮。  Name中填:Pydev,  Location中填http://pydev.org/updates</li>
<li>在Eclipse菜单栏中，点击Windows -&gt;Preferences.<br>
在对话框中，点击pyDev-&gt;Interpreter - Python.  点击New按钮， 选择python.exe的路径, 打开后显示出一个包含很多复选框的窗口. 点OK</li>
</ol>
<h2 id="快速入门">快速入门</h2>
<p>大小写敏感<br>
变量使用前不需要声明<br>
代码不使用大括号,通过缩进表示代码逻辑</p>
<h3 id="输出">输出</h3>
<p><code>print</code><br>
直接使用变量名也可以直接以输出变量的字符串形式</p>
<h3 id="注释">注释</h3>
<p>单行注释使用符号<code>#</code></p>
<h3 id="操作符">操作符</h3>
<p><code>/</code>为普通除法<br>
<code>//</code>为浮点除法<br>
<code>**</code>为乘方<br>
逻辑操作符为<code>and or not</code><br>
可使用<code>3&lt;4&lt;5</code>这样的表达式<br>
不支持<code>--</code>和<code>++</code></p>
<h3 id="数据类型">数据类型</h3>
<h4 id="数字">数字</h4>
<p>int long bool float complex decimal<br>
<strong>long的长度比java大.整型可以自动转换为long,不会有数字溢出</strong><br>
decimal为十进制浮点型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">1.1</span></span><br><span class="line"><span class="number">1.100000000000001</span></span><br><span class="line">&gt;&gt;&gt;print(decimal.Decimal(<span class="string">'1.1'</span>))</span><br><span class="line"><span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>单引号<code>'</code>双引号<code>&quot;</code>都行<br>
<strong>使用三个单引号<code>'''</code>或双引号<code>&quot;&quot;&quot;</code></strong> 可用来包含特殊字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;aStr=<span class="string">'''this</span></span><br><span class="line"><span class="string">...is a string'''</span></span><br><span class="line">&gt;&gt;&gt;pint(aStr)</span><br><span class="line">this</span><br><span class="line"><span class="keyword">is</span> a string</span><br><span class="line">&gt;&gt;&gt;aSre</span><br><span class="line">this\nis a string</span><br></pre></td></tr></table></figure>
<p>第一个字符索引为<code>[0]</code>,最后一个为<code>[-1]</code><br>
<code>[:]</code>可得到子串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;aStr=<span class="string">'python'</span></span><br><span class="line">&gt;&gt;&gt;aStr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">tho</span><br><span class="line"><span class="comment">#包含左端不包含右端.可使用[:3]&#123;2:]格式</span></span><br></pre></td></tr></table></figure>
<p><code>+</code>用于字符串链接<br>
<code>*</code>用于字符串重复</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">'py'</span>+<span class="string">'thon'</span></span><br><span class="line">python</span><br><span class="line">&gt;&gt;&gt;<span class="string">'py'</span>*<span class="number">3</span></span><br><span class="line">pypypy</span><br></pre></td></tr></table></figure>
<h3 id="列表和元组">列表和元组</h3>
<p>列表元素用<code>[]</code>,元组元素用<code>()</code><br>
都可使用切片运算<code>[:]</code></p>
<h3 id="字典">字典</h3>
<p>键值对</p>
<h3 id="if">if</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">	if_suite</span><br><span class="line"><span class="keyword">elif</span> expression:</span><br><span class="line">	elif_suite</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	else_suite</span><br></pre></td></tr></table></figure>
<h3 id="while循环">while循环</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">	while_suite</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3>
<p>更像foreach</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> set:</span><br><span class="line">	print(item)</span><br></pre></td></tr></table></figure>
<p><code>range()</code>函数,指定一个范围,控制循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)</span><br><span class="line">	print(i)</span><br></pre></td></tr></table></figure>
<h3 id="列表解析">列表解析</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squared=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="文件读写">文件读写</h3>
<p><code>file=open(name,mode)</code><br>
r:读取 w:写入 a:添加 +:读写 b:二进制访问 默认为r</p>
<h3 id="函数">函数</h3>
<p>函数通过引用调用,若改变参数值会影响到原始值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">(args)</span>:</span></span><br><span class="line">	<span class="string">'optiinal documentation string'</span></span><br><span class="line">	function_suite</span><br></pre></td></tr></table></figure>
<p>参数可以有默认值<code>def functionName(arg1=value):</code></p>
<h3 id="类">类</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span><span class="params">(base_class[es])</span>:</span></span><br><span class="line">	static_meber</span><br><span class="line">	__init__(self):<span class="comment">#构造函数,自动执行</span></span><br><span class="line">		...</span><br><span class="line"><span class="comment">#创建类</span></span><br><span class="line">aInstance=ClassName()</span><br></pre></td></tr></table></figure>
<p>没有基类的话用<code>(object)</code></p>
<h3 id="一些实用函数">一些实用函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dir([obj])</td>
<td>显示对象的属性,若无参数,则显示全局变量的名字</td>
</tr>
<tr>
<td>help([obj])</td>
<td>显示对象的文档,若无参数进入帮助模式</td>
</tr>
<tr>
<td>int(obj)</td>
<td>转换为整型</td>
</tr>
<tr>
<td>len(obj)</td>
<td>对象的长度</td>
</tr>
<tr>
<td>range([start],stop,[step])</td>
<td>返回整型列表,[srart,stop),start默认0,step默认1</td>
</tr>
<tr>
<td>str(obj)</td>
<td>转换为字符串</td>
</tr>
<tr>
<td>type(obj)</td>
<td>返回对象的类型</td>
</tr>
</tbody>
</table>
<h3 id="语句语法">语句语法</h3>
<ul>
<li>换行为行分隔符</li>
<li><code>\</code>继续,即下一行与本行为同一行代码<br>
<code>() [] {} 和 ''' '''-</code>间的代码可多行书写,不需要\</li>
<li>;`分隔一行中的两个语句</li>
<li><code>:</code>分隔代码块的头和体</li>
<li>代码组由不同的缩进分隔</li>
</ul>
<h3 id="参数赋值">参数赋值</h3>
<p><strong>对象都是通过引用传递的</strong><br>
可进行链式赋值<code>x=y=z=1</code><br>
多元赋值<code>x,y,z=1,2,3</code>,此时建议使用括号<br>
交换两个变量的值(x,y)=(y,x)</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令]]></title>
      <url>/2017/11/26/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站</a>, 十分全面详细。</p>
<h1>本地操作</h1>
<h2 id="把当前目录初始化为git仓库">把当前目录初始化为git仓库</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure>
<h2 id="把文件添加到git仓库">把文件添加到git仓库</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<h2 id="把文件提交到仓库-一次commit可以提交多个文件">把文件提交到仓库.一次commit可以提交多个文件。</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>
<h2 id="查看文件状态">查看文件状态</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#    modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="对比文件修改">对比文件修改</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>
<h2 id="查看提交日志-加-pretty-oneline输出简化版结果">查看提交日志.加<code>--pretty=oneline</code>输出简化版结果</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8cd576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<h2 id="查看所有日志">查看所有日志</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>
<h2 id="修改撤销">修改撤销</h2>
<h3 id="丢弃工作区的修改">丢弃工作区的修改</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：<br>
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h3 id="丢弃暂存区修改">丢弃暂存区修改</h3>
<p>用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure>
<h3 id="版本回滚">版本回滚</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at ea34578 add distributed</span><br></pre></td></tr></table></figure>
<p>用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<h2 id="删除文件">删除文件</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &apos;test.txt&apos;</span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d17efd8] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<h1>远程仓库</h1>
<h2 id="与远程仓库关联">与远程仓库关联</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<h2 id="把本地库推送到远程">把本地库推送到远程</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 19, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (19/19), done.</span><br><span class="line">Writing objects: 100% (19/19), 13.73 KiB, done.</span><br><span class="line">Total 23 (delta 6), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master set up to track remote branch master from origin.</span><br></pre></td></tr></table></figure>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>
此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<h2 id="克隆远程仓库">克隆远程仓库</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into &apos;gitskills&apos;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br><span class="line"></span><br><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>
<h2 id="查看远程库信息">查看远程库信息</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>
<h2 id="忽略部分文件">忽略部分文件</h2>
<p><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<h1>分支管理</h1>
<h2 id="创建分支及切换">创建分支及切换</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure>
<h2 id="查看当前分支">查看当前分支</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<h2 id="合并分支到当前分支">合并分支到当前分支</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>使用<code>git log --graph</code>可以查看分支合并情况</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<h2 id="删除分支">删除分支</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was fec145a).</span><br></pre></td></tr></table></figure>
<h2 id="保存工作现场">保存工作现场</h2>
<p>将未提交的文件保存起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 6224937 add merge</span><br><span class="line">HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure>
<p>查看保存的工作现场</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 6224937 add merge</span><br></pre></td></tr></table></figure>
<p>恢复现场<br>
一是用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除;另一种方式是用<code>git stash pop</code>，恢复的同时把<code>stash</code>内容也删了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line"># On branch dev</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       new file:   hello.py</span><br><span class="line">#</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span><br></pre></td></tr></table></figure>
<h1>多人协作</h1>
<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin branch-nam</code>e推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li>
<li>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。<br>
这就是多人协作的工作模式，一旦熟悉了，就非常简单。</li>
</ol>
<h2 id="更新远程代码到本地-在本地有修改的情况下">更新远程代码到本地(在本地有修改的情况下)</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line"></span><br><span class="line">$ git diff temp//比较master分支和temp分支的不同</span><br><span class="line"></span><br><span class="line">$ git merge temp//合并temp分支到master分支</span><br><span class="line"></span><br><span class="line">$ git branch -d temp//删除temp</span><br></pre></td></tr></table></figure>
<p>merge执行时可能有如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">    xxx/xxx/xxx.java</span><br><span class="line">Please, commit your changes or stash them before you can merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>此时可以先commit自己的修改<br>
或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git merge temp</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[囚徒健身]]></title>
      <url>/2017/11/23/%E5%9B%9A%E5%BE%92%E5%81%A5%E8%BA%AB/</url>
      <content type="html"><![CDATA[<ol>
<li><strong>热身</strong>。使用该类动作的前几式用于热身。做两组，第一组20，第二组15。</li>
<li><strong>慢工出细活</strong>。做动作要慢，使用肌肉控制动作；不要急于进阶，将一级动作练到完美再升级。</li>
<li><strong>留有余力</strong>。不要做到力竭，要留有一点余力，保证动作完整不变形。</li>
</ol>
<h1>俯卧撑</h1>
<h2 id="要点">要点</h2>
<ol>
<li>避免诡异的角度和手部姿势。找到适合自己的锻炼姿势。</li>
<li>躯干、髋部、双腿始终要成一条直线。只有那些腰部力量太弱无法锁定躯干的人，才会出现做俯卧撑时撅屁股的情况。</li>
<li>双腿始终要并拢。如果双腿分开，做动作时就无需保持躯干稳定，练习就变容易了。</li>
<li>在动作最高点时，双臂要伸直，但不要让肘部完全锁定，而要使其微弯，以免关节不舒服。（有时这被描述为让手臂保持“柔软”。）</li>
<li>要平缓地呼吸。根据我的经验：上推时应呼气，下降时应吸气。但如果你感觉呼吸费力，就不要遵循这一原则，而要多呼吸几次。</li>
</ol>
<h2 id="第一式：墙壁俯卧撑">第一式：墙壁俯卧撑</h2>
<p><strong>动作：</strong><br>
面对墙壁站立，双脚并拢，双臂伸直，与肩同宽，双手平放在墙上，手掌与胸等高。这是该动作的起始姿势。弯曲肘部，直到前额轻触墙面。这是该动作的结束姿势。</p>
<p><img src="/2017/11/23/囚徒健身/1-1-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/1-1-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X25</td>
<td>3X50</td>
</tr>
</tbody>
</table>
<h2 id="第二式：上斜俯卧撑">第二式：上斜俯卧撑</h2>
<p><strong>动作：</strong><br>
做这个动作需要借助一个稳固的物体，高度大约是你身高的一半（大概到臀部位置）。<br>
双脚并拢，身体成一条直线，然后前倾上身，双臂伸直，双手抓住所选物体，与肩同宽。这是该动作的起始姿势。<br>
弯曲肘部，放低身体，直到胸部轻触物体顶部。如果你选择的物体高度合适，那么此时你的身体与地面的夹角约为45°。暂停一会，然后将自己推回到起始姿势，如此重复。</p>
<p><img src="/2017/11/23/囚徒健身/1-2-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/1-2-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X20</td>
<td>3X40</td>
</tr>
</tbody>
</table>
<h2 id="第三式：膝盖俯卧撑">第三式：膝盖俯卧撑</h2>
<p><strong>动作：</strong><br>
双脚并拢，双膝着地。双臂伸直，与肩同宽。双手在胸部的正下方，两个手掌平放在地面上。脚踝搭在一起，大腿与上身及头部成一条直线，不要撅屁股或者塌腰。这是该动作的起始姿势（图5）。然后以膝盖为支点，弯曲肘部，直到胸部与地面仅一拳之隔（图6）。暂停一下，然后将自己推回到起始姿势，如此重复。</p>
<p><img src="/2017/11/23/囚徒健身/1-3-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/1-3-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X15</td>
<td>3X30</td>
</tr>
</tbody>
</table>
<h2 id="第四式：半俯卧撑">第四式：半俯卧撑</h2>
<p><strong>动作：</strong><br>
跪在地板上，双手撑地，双腿向后蹬直。双手与肩同宽，并处于上胸部的正下方。双腿双脚并拢，锁紧身体，使上身、髋部和双腿成一条直线。先伸直手臂，然后降低身体到大约一半臂长的高度，或者直到肘部弯成直角。控制下降高度的绝佳方式就是使用篮球或橄榄球——将球放在髋部下方。这是该动作的起始姿势（图7）。接下来，弯曲肘部，直到髋部与球轻轻接触（图8）。对大多数人来说，这样可以方便且客观地标示这个动作的最低点。暂停一下，然后用力将自己推回到起始姿势。</p>
<p><img src="/2017/11/23/囚徒健身/1-4-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/1-4-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X15</td>
<td>3X25</td>
</tr>
</tbody>
</table>
<h2 id="第五式：标准俯卧撑">第五式：标准俯卧撑</h2>
<p><strong>动作：</strong><br>
跪在地板上，双手撑地，双腿向后蹬直。双腿双脚并拢，双手与肩同宽，并处于上胸部的正下方。双臂伸直，臀部与脊椎成一条直线。这是该动作的起始姿势（图9）。接着，弯曲肘部，直至胸部与地面仅一拳之隔。监狱里进行俯卧撑比赛时，计数者会握拳，让小拇指一侧紧贴地面，这样只需数参赛者胸部接触自己大拇指的次数即可。若你是单独锻炼，又想控制动作幅度，并想让身体与地面保持正确距离，可以在胸部正下方放一个棒球或网球（图10）。你在做动作的过程中，待胸部碰到球后暂停一下，然后回到起始姿势。</p>
<p><img src="/2017/11/23/囚徒健身/1-5-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/1-5-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X5</td>
<td>2X10</td>
<td>3X20</td>
</tr>
</tbody>
</table>
<h1>深蹲</h1>
<h2 id="要点-v2">要点</h2>
<ol>
<li>动作进行到最低点时，大腿后侧会紧贴小腿，你的身体将<strong>无法继续降低</strong>。这时，需要大腿和膝盖共同发力才能将身体推起，直到双腿<strong>完全伸直</strong>。</li>
<li>在动作的反向过程中，不要直接就那样蹲下了，而要用肌肉力量有控制地下蹲。</li>
<li>在蹲过程中身体要前倾，但不要过分前倾。因为这样将过分锻炼髋部，而忽略了大腿。前倾是必要的，但不要养成向前弓背的习惯。</li>
<li>最低点的姿势是深蹲中最难控制的部分——几乎所有练习都是如此，不过深蹲尤甚。尽管难度很高——做单腿深蹲时尤其难，但你在深蹲中绝不能快速下蹲，然后直接“反弹”（靠惯性）站起，这会严重损伤膝关节处的软骨。你应该通过前几式的练习慢慢增强肌腱的力量。</li>
<li>起身前不要摇晃。</li>
<li>不要踮起脚跟。</li>
</ol>
<h2 id="第一式：肩倒立深蹲">第一式：肩倒立深蹲</h2>
<p><strong>动作：</strong></p>
<p>平躺，双膝弯曲，双手下压。双脚蹬离地面，直到举到空中。在将双腿举起的过程中，顺势把双手撑在下背部，注意上臂要紧贴地面。你现在摆出的姿势是肩倒立——靠双肩、上背部以及上臂支撑身体。要记住，始终用这几个部位支撑身体，不要让颈部受到压力。身体要锁定伸直，髋部不要弯曲。这是该动作的起始姿势（图21）。上半身要尽可能伸直，弯曲髋部与膝关节，直到膝盖轻触前额，这是该动作的结束姿势（图22）。然后伸直双腿，直到身体回到起始姿势，如此重复。</p>
<p><img src="/2017/11/23/囚徒健身/2-1-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/2-1-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X25</td>
<td>3X50</td>
</tr>
</tbody>
</table>
<h2 id="第二式：折刀式深蹲">第二式：折刀式深蹲</h2>
<p><strong>动作：</strong></p>
<p>站在一个稳固的物体前，此物体的高度大约与你的膝盖等高，至少也要达到胫骨上部，小咖啡桌、椅子、床铺都是不错的选择。双腿分开，与肩同宽或略宽。双腿伸直，弯腰俯身，直到双手与面前的物体接触。身体前倾，使一部分体重落在双手上。这是该动作的起始姿势（图23）。上半身尽量与地面平行，弯曲膝关节和髋部，直到大腿后侧紧贴小腿，无法蹲得更低为止。这是该动作的最低点（图24）。下蹲过程中你还需要弯曲双臂，在下降到最低点后腿部与手臂要同时发力，将身体推回到起始姿势。在整个动作过程中，脚跟始终不能抬离地面。</p>
<p><img src="/2017/11/23/囚徒健身/2-2-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/2-2-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X20</td>
<td>3X40</td>
</tr>
</tbody>
</table>
<h2 id="第三式：支撑深蹲">第三式：支撑深蹲</h2>
<p><strong>动作：</strong></p>
<p>直立，双脚分开，与肩同宽或略宽。手臂向斜下方伸出，双手放在比自己的大腿略高的稳固物体上，书桌、高脚凳或椅背都可以。这是该动作的起始姿势（图25）。弯曲髋部与膝关节，身体慢慢下降，背部尽可能保持挺直，直到大腿后侧紧贴小腿，无法蹲得更低为止，这是该动作的最低点（图26）。暂停一会，然后主要靠腿部发力站起来。为了分担双腿的一部分压力，尤其是在最低点时，你要通过向下按压面前的物体，来借用手臂的一部分力量。</p>
<p><img src="/2017/11/23/囚徒健身/2-3-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/2-3-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X15</td>
<td>3X30</td>
</tr>
</tbody>
</table>
<h2 id="第四式：-半深蹲">第四式： 半深蹲</h2>
<p><strong>动作：</strong></p>
<p>站立，双脚分开，与肩同宽或略宽。脚尖不要正对前方，而要略微向外。双手放在髋部、胸部、肩部都可以——以舒适为前提。这是该动作的起始姿势（图27）。弯曲髋部和膝盖，直到膝关节弯曲成90°——换句话说就是大腿与地面平行。这是该动作的最低点（图28）。刚开始你可以借助一面镜子或是找朋友帮忙，直到能够自如地控制动作幅度。不要求快，也不要借助惯性起身，而要完全在肌肉控制下做整个动作。在最低点（半空中）坚持1秒钟，然后再回到起始姿势。在整个动作过程中，背部始终要挺直，双脚脚跟始终不能抬离地面。膝盖与脚尖应该始终朝向同一方向，深蹲时膝盖绝不要向内转，脚尖指向外有助于你做到这一点。</p>
<p><img src="/2017/11/23/囚徒健身/2-4-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/2-4-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X35</td>
<td>3X50</td>
</tr>
</tbody>
</table>
<h2 id="第五式：-标准深蹲">第五式： 标准深蹲</h2>
<p><strong>动作：</strong></p>
<p>直立，双脚分开，与肩同宽或略宽（取决于个人偏好）。双脚略微向外转，双臂随意摆放，只要舒服即可。这是该动作的起始姿势（图29）。髋部与膝关节弯曲，背部始终挺直。 当大腿达到几乎与地面平行时，把你的身体重心向后转移，就像要坐下一样。有控制地继续放低身体，直到大腿后侧紧贴小腿。这是该动作的最低点（图30）。暂停一会，然后仅靠腿部发力将自己推回到起始姿势。起身过程和下蹲过程应该是完全相反的。脚跟始终不要抬离地面，膝盖也不能向内转。</p>
<p><img src="/2017/11/23/囚徒健身/2-5-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/2-5-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X5</td>
<td>2X10</td>
<td>3X30</td>
</tr>
</tbody>
</table>
<h1>引体向上</h1>
<h2 id="要点-v3">要点</h2>
<ol>
<li>做引体向上以下巴超过横杆为最佳。</li>
<li>在起始姿势中，肘部要微微弯曲。</li>
<li>为了稳住上身，肩部也要保持“收紧”的状态。</li>
<li>抓握姿势有正握（指根关节朝向自己）、反握（指尖朝向自己）、侧握（拇指朝向自己),选择最舒服的姿势即可。最好使用吊环。</li>
<li>千万不要蹬腿。应当借助肌肉的力量完成动作而非惯性。（蹬腿可以作为过渡过程中增加动作次数的辅助练习）</li>
</ol>
<p><img src="/2017/11/23/囚徒健身/3-0-1.jpg" alt="肩部收紧"></p>
<h2 id="第一式：垂直引体">第一式：垂直引体</h2>
<p><strong>动作：</strong><br>
找一个可抓握且很稳固的竖直物体。靠近物体站立，脚尖与之保持约8-15厘米的距离。以舒服的姿势抓住该物体，理想情况是双手与肩同宽，但不必要——只要双手对称即可。这是该动作的起始姿势（图41）。由于你距离物体很近，所以手臂会弯曲。身体慢慢向后倾，在此过程中伸展手臂，直到手臂几乎伸直、身体后倾与地面成一定角度为止。这是该动作的结束姿势（图42）。此时，你的上背部应该有拉伸感，手臂可能也会有同感。暂停一会，再并拢肩脚骨并弯曲手臂，把身体拉回到起始姿势。暂停，然后再重复该动作。</p>
<p><img src="/2017/11/23/囚徒健身/3-1-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/3-1-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X20</td>
<td>3X40</td>
</tr>
</tbody>
</table>
<h2 id="第二式：水平引体">第二式：水平引体</h2>
<p><strong>动作：</strong><br>
找一个至少与你的髋部等高、稳固且双手可抓握的水平物体。该物体要能安全地承载你的体重，又大又结实的桌子（如餐桌和书桌）通常是最佳之选。钻到桌子下面——胸部与下肢都位于桌子下面，抬手抓住桌子边缘（使用正握姿势）。理想情况是，双手与肩同宽，但这要取决于你用的是什么样的桌子。然后拉起身体，使背部离地，只有脚跟与地面接触。有时你的手臂可能需要适当弯曲才能使背部离地——这取决于桌子的高度。身体绷紧，让双手和双脚脚跟承担身体的重量。这是该动作的起始姿势（图43）。然后平缓地拉起身体，在此过程中整个身体（尤其是膝盖）要成一条直线，直到胸部触到桌子边缘。这是该动作的结束姿势（图44）。暂停一下，然后降低身体，回到起始姿势，如此重复。</p>
<p><img src="/2017/11/23/囚徒健身/3-2-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/3-2-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X20</td>
<td>3X30</td>
</tr>
</tbody>
</table>
<h2 id="第三式：折刀引体向上">第三式：折刀引体向上</h2>
<p><strong>动作：</strong><br>
练习折刀引体向上需要高一点的横杆，横杆下面放一把高脚凳或类似物体。向上跳起抓住横杆，手臂大约与肩同宽，采取正握姿势。用横杆训练时，肩部始终要收紧，手臂也不能完全放松，肘部微微弯曲。将双腿向上摆，把双脚脚跟搭在横杆前方的高脚凳上，双腿要完全伸直。该物体要足够高，理想情况是双腿伸直时脚踝与骨盆恰好在同一高度，此即经典的折刀角度。这是该动作的起始姿势（图45）。然后平缓地把身体拉起，伸直的双腿向下压以帮助完成动作，最后使下巴高过横杆。这是该动作的结束姿势（图46）。</p>
<p><img src="/2017/11/23/囚徒健身/3-3-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/3-3-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X15</td>
<td>3X20</td>
</tr>
</tbody>
</table>
<h2 id="第四式：半引体向上">第四式：半引体向上</h2>
<p><strong>动作：</strong><br>
选择足够高的横杆，使得身体悬垂在上面时双脚依然离地，即便只离地一厘米也可以。 向上跳起抓住横杆，采用正握姿势，两手与肩同宽或略宽，双臂弯曲接近90°上臂应与地面平行），肩部始终收紧。膝部微屈，脚躁交叠在一起，以免双腿辅助借力。这是该动作的起始姿势（图47）。弯曲肘部，夹起肩部，平缓地拉起身体，直到下巴超过横杆。这是该动作的结束姿势（图48）。在最高处暂停一下，然后有控制地下降到起始姿势。在动作过程中肘部可以向前移动，但两腿应始终保持不动。</p>
<p><img src="/2017/11/23/囚徒健身/3-4-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/3-4-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X11</td>
<td>3X15</td>
</tr>
</tbody>
</table>
<h2 id="第五式：标准引体向上">第五式：标准引体向上</h2>
<p><strong>动作：</strong><br>
以正握姿势握住横杆，双手与肩同宽或略宽——你可以试试看多大宽度对你来说最容易发力。双脚离地，双膝微屈，脚踝交叠在一起并置于身后。身体绷紧，双肩收紧，肘部略微弯曲（几乎看不出来），让肌肉而不是肘关节承担压力。这是该动作的起始姿势（图49）。<br>
弯曲肘部，夹起肩部，直至下巴超过横杆。这是该动作的结束姿势（图50）。欣赏一下上面的风景吧！暂停一会，然后有控制地反向运动。不要做爆发式动作，否则惯性就会参与进来。</p>
<p><img src="/2017/11/23/囚徒健身/3-5-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/3-5-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X5</td>
<td>2X8</td>
<td>3X10</td>
</tr>
</tbody>
</table>
<h1>举腿</h1>
<h2 id="要点-v4">要点</h2>
<ol>
<li>呼吸会收紧腹部肌肉和肋间肌。为了最大化这种效果，在放下双腿时吸气，在动作进行到最高点呼气完毕。若有必要，可以在两次动作之间喘几口气。</li>
<li>腹横肌是腰部深处的肌肉层，其作用就像紧身胸衣一样，能够把内脏固定在特定位置。 腹横肌如果很弱，在压力之下就可能被撕裂，使一些内脏向外凸出，形成疝气。在腹肌练习中，应该通过紧紧收缩腹部来锻炼腹横肌。在日常生活中始终通过收腹保持好姿势也会有锻炼效果。</li>
<li>做腹部练习之前，要确定胃里的食物已经消化得差不多了。吃饭与练习腹肌的时间间隔至少为两小时，否则会出现腹胀，从而影响动作。</li>
<li>如果你发现直腿举腿很难，这可能是由于你的胸绳肌过紧所致。训练前先拉伸腘绳肌，情况会好一些。</li>
<li>在举腿练习的最低点，如果用一点儿惯性摆动身体，动作就会变得容易不少，千万不要这样做。如果你的举腿动作没法干净利落，那就回到上一式，直到你足够强再以正确的动作练习下一式。</li>
</ol>
<h2 id="第一式：-坐姿曲腿">第一式： 坐姿曲腿</h2>
<p><strong>动作：</strong></p>
<p>坐在椅子或床的边缘，身体略微向后倾斜，双手抓住边沿，两腿伸直，双脚并拢，脚跟距离地面几厘米。这是该动作的起始姿势（图61）。平缓地抬起膝盖，直到膝盖距胸部约15—25厘米。在此过程中呼气，动作完成时呼气结束，腹肌保持收缩状态。这是该动作的结束姿势（图62）。暂停1秒钟，进行反向运动并回到起始姿势。伸展膝盖的同时吸气。双脚应该始终沿着一条直线移动，而且始终保持悬空，直到一组动作完成方可接触地面。腹部要始终收缩，动作要慢，要抵制快速完成动作的冲动。如果需要，可以在两次动作之间喘几口气（所有中段练习都一样）。</p>
<p><img src="/2017/11/23/囚徒健身/4-1-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-1-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X25</td>
<td>3X40</td>
</tr>
</tbody>
</table>
<h2 id="第二式：-平卧抬膝">第二式： 平卧抬膝</h2>
<p><strong>动作：</strong></p>
<p>平躺在地上，双腿并拢，双手置于身体两侧的地板上。膝盖弯曲近90°双脚距离地面约2—5厘米。双手用力向下按压地板，这样有助于保持身体稳定。这是该动作的起始姿势（图63）。然后平缓地抬起膝盖，越过髋部，直到大腿与地面垂直、小腿与地面平行，整个过程中膝盖始终接近90°。在此过程中呼气，腹部肌肉保持收紧。这是该动作的结束姿势（图64）。暂停1秒钟，进行反向动作。降低双脚，回到起始姿势，并在此过程中吸气。在整组练习中双脚都不能接触地面。</p>
<p><img src="/2017/11/23/囚徒健身/4-2-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-2-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X20</td>
<td>3X35</td>
</tr>
</tbody>
</table>
<h2 id="第三式：-平卧屈举腿">第三式： 平卧屈举腿</h2>
<p><strong>动作：</strong><br>
平躺在地上，双腿并拢伸展，双手置于身体两侧的地面上。双腿抬起，膝盖弯曲，使大腿与小腿的夹角大约成135°双脚距离地面约2—5厘米。这是该动作的起始姿势（图65）。 该练习前半部分的动作包括平缓地抬起双腿和双脚，持续大约2秒钟，直到双脚位于骨盆正上方（图66）。在整个动作过程中，膝盖弯曲的角度应该保持不变——始终“锁定”。双手向下按压地板，这样有助于保持身体稳定。两脚位于骨盆正上方时，略作停顿，然后进行反向动作。在回复到起始姿势时也略作停顿，然后重复以上过程。双脚向上运动时呼气，向下运动时吸气。在整组练习中，腹部始终都要收紧，双脚始终不能接触地面。</p>
<p><img src="/2017/11/23/囚徒健身/4-3-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-3-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X15</td>
<td>3X30</td>
</tr>
</tbody>
</table>
<h2 id="第四式：-平卧蛙举腿">第四式： 平卧蛙举腿</h2>
<p><strong>动作：</strong><br>
先做第三式前半部分的屈举腿动作，但在最高点的时候（图66）不要停顿，而是要完全伸直双腿，使其与地面垂直，并与上半身的夹角成90°这是该动作的结束姿势（图67）。 应该在这个两部分的动作过程中呼气。大多数中段练习此时都要反向重复前半部分的动作，但这个练习有所不同。在有阻力（重力）的情况下降低双腿比抬起双腿要容易，蛙举腿正利用了这一点。降低双腿并保持完全伸展（图68），直到双腿距离地面约2-5厘米（图69）。<br>
大多数练习动作中上与下的过程都要经过2秒钟，但该练习的下落过程要经过4秒钟，以便身体在有利的姿势中获得更多的锻炼。双腿慢慢下降时吸气，然后重复以上动作。</p>
<p><img src="/2017/11/23/囚徒健身/4-4-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-4-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X15</td>
<td>3X25</td>
</tr>
</tbody>
</table>
<h2 id="第四式：-平卧蛙举腿-v2">第四式： 平卧蛙举腿</h2>
<p><strong>动作：</strong><br>
先做第三式前半部分的屈举腿动作，但在最高点的时候（图66）不要停顿，而是要完全伸直双腿，使其与地面垂直，并与上半身的夹角成90°这是该动作的结束姿势（图67）。 应该在这个两部分的动作过程中呼气。大多数中段练习此时都要反向重复前半部分的动作，但这个练习有所不同。在有阻力（重力）的情况下降低双腿比抬起双腿要容易，蛙举腿正利用了这一点。降低双腿并保持完全伸展（图68），直到双腿距离地面约2-5厘米（图69）。<br>
大多数练习动作中上与下的过程都要经过2秒钟，但该练习的下落过程要经过4秒钟，以便身体在有利的姿势中获得更多的锻炼。双腿慢慢下降时吸气，然后重复以上动作。</p>
<p><img src="/2017/11/23/囚徒健身/4-4-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-4-2.jpg" alt="中间姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-4-3.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X15</td>
<td>3X25</td>
</tr>
</tbody>
</table>
<h2 id="第五式：-平卧直举腿">第五式： 平卧直举腿</h2>
<p><strong>动作：</strong><br>
平躺在地上，面部朝上。双脚并拢，双腿伸直，双手置于身体两侧。抬起双脚，使其距离地面约2-5厘米。双手向下按压地板，以保持身体稳定。这是该动作的起始姿势（图70）。 双腿锁定，抬起双脚直到它们到达骨盆正上方，即双腿与上半身的夹角成90°这是该动作的结束姿势（图71）。抬脚的过程中呼气，腹部保持收紧。至少要用2秒钟平缓地完成该动作，不要用猛劲。停顿片刻，然后反向动作，降低双腿的过程中吸气。到达起始姿势后略作停顿，再重复。在整个动作过程中，膝盖始终要锁定，双脚不能接触地面，直到一组完成之后方可。</p>
<p><img src="/2017/11/23/囚徒健身/4-5-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/4-5-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X5</td>
<td>2X10</td>
<td>3X20</td>
</tr>
</tbody>
</table>
<h1>桥</h1>
<h2 id="要点-v5">要点</h2>
<ol>
<li>脊柱应该形成凹面，背部必须形成优美的弧形。说来简单，但如果脊柱的深层肌肉很弱，那么训练者就倾向于使用四肢撑起身体，这样背部会显得很直挺。</li>
<li>背部应该远离地面。孱弱的桥最明显标志就是髋部只能勉强离地；完美的桥，髋部与臀部应该比头部和肩脚骨要高。这点很难判断，除非你从侧面给自己拍一张照片。</li>
<li>双臂与双腿应该伸直。做桥时，双臂伸直相对容易，但要双腿与其同时伸直，则需要训练者具有非常好的柔韧性。</li>
<li>呼吸应该又深又平缓。桥使胸腔伸展，使肺部受到压力，如果胸部僵硬，那训练者的呼吸会急促不平。自然的呼吸是掌握桥的标志。切记，练习时绝不要屏住呼吸。</li>
</ol>
<h2 id="第一式：短桥">第一式：短桥</h2>
<p><strong>动作：</strong><br>
躺在地上，双手叠放在腹部。膝盖弯曲，将双脚拉向臀部，直到胫骨与地面接近垂直，此时脚跟距离臀部约 15~20 厘米，脚掌平放在地上。双脚与肩同宽或略窄，依个人舒适度而定。这是起始姿势（图83）。然后双脚用力下压，身体向上拱起，使髋部和背部离开地面，直到仅以双肩和双脚支撑整个身体。此时，大腿和躯干应成一条直线，髋部不要下沉。这是结束姿势（图84）。暂停一会，然后做反向动作，缓缓地放低身体，直到回到起始姿势，如此重复。身体撑起时呼气身体放低时吸气。</p>
<p><img src="/2017/11/23/囚徒健身/5-1-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/5-1-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X25</td>
<td>3X50</td>
</tr>
</tbody>
</table>
<h2 id="第二式：直桥">第二式：直桥</h2>
<p><strong>动作：</strong><br>
坐在地上，双腿伸直，双脚与肩同宽。手掌平放在髋部两侧的地上，手指朝前。坐直，此时腿和上半身之间的夹角成90°，这是该动作的起始姿势（图85）。双手用力下压，双臂绷紧，同时将髋部向上推起，直到双腿与躯干成一条直线。下巴向上抬起，看向天花板，此时只用手掌和脚跟支撑身体。这是结束姿势（图86）。暂停一会，然后反向运动。身体撑起时呼气，身体放低时吸气。</p>
<p><img src="/2017/11/23/囚徒健身/5-2-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/5-2-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X10</td>
<td>2X20</td>
<td>3X40</td>
</tr>
</tbody>
</table>
<h2 id="第三式：高低桥">第三式：高低桥</h2>
<p><strong>动作：</strong><br>
高低桥需要借助一个与膝盖等高或略高的物体，在监狱里，床铺是最好的选择。一般家庭里的床稍高一点，但也可以。坐在床的边缘，身体向后躺在床上，双脚平放地上，与肩同宽。身体往前挪，以便髋部离开床。双手放在头部两侧，手指指向脚。这是该动作的起始姿势（图87）。双手用力下压，肘部打开，推起髋部，同时背部弯起成弧形。继续平缓地尽力上推身体，至少让头部与身体完全离开床。手臂不必完全伸直，肘部应该是弯曲的。或许你只能将自己的身体推起几厘米，那就可以了。有控制地向后仰头，以便能看见身后的墙壁。</p>
<p><img src="/2017/11/23/囚徒健身/5-3-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/5-3-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X15</td>
<td>3X30</td>
</tr>
</tbody>
</table>
<h2 id="第四式：顶桥">第四式：顶桥</h2>
<p><strong>动作：</strong><br>
平躺在地上，弯曲膝盖，把脚拉向臀部，直到脚跟与臀部相距约15-20厘米。双脚与肩同宽或略窄，双手撑在头部两侧的地板上，手指指向脚，两肘指向天花板。尽力抬起髋部，使身体离地。手臂与腿继续用力推，直到背部形成优美的弧形，髋部高高抬起。头向下仰，头顶指向地板，这是“桥式”。保持这个姿势一会儿，然后弯曲手臂与双腿，直到头部轻轻接触地板。这是该动作的起始姿势（图89）。再次暂停一会，然后将背部向上推起成“桥式”。<br>
这是该动作的结束姿势（图90）。运动过程中要小心，以免撞到头部。在整个练习组中，背部始终要保持弧形，并且尽量正常呼吸。完成训练目标之后，慢慢地放低肩部、背部和髋部，直至整个身体接触地面。</p>
<p><img src="/2017/11/23/囚徒健身/5-4-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/5-4-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X15</td>
<td>3X25</td>
</tr>
</tbody>
</table>
<h2 id="第五式：半桥">第五式：半桥</h2>
<p><strong>动作：</strong><br>
这个动作需要借助一个篮球或足球来控制动作幅度。坐在地上，把球放在自己身后的地上（靠近自己）。向后躺，只有双肩和双脚在地面上，双脚与肩同宽或略窄，球支撑着腰部。 如果你感觉这种姿势不舒服，在开始前可以在球上放上毛巾或坐垫。双手撑在头部两侧的地板上，手指指向脚。然后，用手把双肩和头部推离地板，只用双脚、球和手掌支撑身体。这是该动作的起始姿势（图91）。在这个姿势基础上髋部要尽力向上顶起，伸展手臂和双腿，抬起背部，直到背部完全离开球。继续向上运动，直到背部形成完全的弧形。这是结束姿势（图92）。在最高处暂停一会，然后慢慢放低身体，回到起始姿势。在一组动作过程中，后腰只能轻轻接触球，而不能将整个身体的重量都压在球上。重复练习，尽量保持正常呼吸。</p>
<p><img src="/2017/11/23/囚徒健身/5-5-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/5-5-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X8</td>
<td>2X15</td>
<td>3X20</td>
</tr>
</tbody>
</table>
<h1>倒立撑</h1>
<h2 id="要点-v6">要点</h2>
<ol>
<li>蹬起时双手不要离墙太近——约15—25厘米（有时更远）会更稳定。双手与肩同宽，重量训练者也许倾向于更宽一些，但那样会不太稳定，并使动作缺乏效率。</li>
<li>练习倒立撑时，不要像做推举那样强迫两肘分开。肘部会自然向内，或者正对着胸前，或者略微斜向外。哪种都可以，舒服即可。</li>
<li>身体不要完全伸直，要略微向前弯曲。双脚比头部更靠后（见图112），这是身体倒立时最自然的平衡方式。背部既不要过度弯曲，也不要完全伸展，保持一定的弧度。</li>
<li>刚开始练习时，你可能想把背部抵在墙上，以分担体重，这可不是好习惯。你最终要达到的是只有双脚脚跟接触墙壁的水平。遵循上面的技巧要点——双手与墙壁有一定距离，身体弯成一定的弧度——双脚脚跟自然而然就会成为身体与墙壁的唯一接触点。你无需强迫自己摆任何怪异的姿势。</li>
<li>初学者先掌握窄距俯卧撑，即俯卧撑系列的第六式（参见第五章），然后再尝试倒立撑系列的第一式，</li>
</ol>
<h2 id="第一式：靠墙顶立">第一式：靠墙顶立</h2>
<p><strong>动作：</strong><br>
找一堵墙，在墙根处放置一个枕头（坐垫或叠好的毛巾也可）。双手和双膝着地，将头顶在枕头上，头部距离墙壁约15—25厘米。双手稳稳地放在头部两侧，大约与肩同宽。抬起一条腿的膝盖，让其靠近同侧的肘部，同时伸直另一条腿，使膝盖离地（图107）。然后，让靠近肘部的腿使劲蹬地，同时将另一条腿向上踢，从而让两条腿同时靠向墙壁。一旦双脚靠在墙壁上，就慢慢伸直双腿，把身体摆正（图108）。嘴巴保持闭合，用鼻子平缓呼吸。 坚持所需时间后，弯曲双腿，并有控制地放下它们。</p>
<p><img src="/2017/11/23/囚徒健身/6-1-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/6-1-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>30s</td>
<td>1min</td>
<td>2min</td>
</tr>
</tbody>
</table>
<h2 id="第二式：乌鸦式">第二式：乌鸦式</h2>
<p><strong>动作：</strong><br>
双膝分开，呈蹲坐姿势。双手手掌放在身体前面的地板上，与肩同宽。双臂略微弯曲，身体向前倾斜，然后让双膝稳稳地夹在两肘外侧（图109）。身体继续前倾，一点一点把体重转移到手掌上，双脚的负重则越来越少。最终重心前移，双脚离地。双脚用力提起，保持平衡，平缓呼吸，坚持一定的时间（图110）。然后反向运动，身体重心慢慢后倾，直到脚尖再次接触地面。</p>
<p><img src="/2017/11/23/囚徒健身/6-2-1.jpg" alt="乌鸦式"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>10s</td>
<td>30s</td>
<td>1min</td>
</tr>
</tbody>
</table>
<h2 id="第三式：靠墙倒立">第三式：靠墙倒立</h2>
<p><strong>动作：</strong><br>
找一面墙，双手手掌平放在距离墙根约15-25厘米的地面上，双手与肩同宽。手臂伸直或近乎伸直，膝盖弯曲，撑起身体。提起一条腿的膝盖，让其靠近同侧的肘部（图111），然后使劲向下蹬地，同时让另一条腿向后上方摆。与此同时，让蹬地的腿也离地，紧随另一条腿向墙壁靠近，手臂保持伸展，双脚脚跟应同时接触墙壁。刚开始练习时，上踢的力量如果过大，你的后背和屁股会猛地撞到墙上，但久而久之你就会掌握完美的上墙技艺。最后，你的手臂应该是直的，身体摆正，背部略向内弓。这就是标准的靠墙倒立姿势（图112）。 保持这一姿势一段时间，整个过程中保持正常呼吸。</p>
<p><img src="/2017/11/23/囚徒健身/6-3-1.jpg" alt="起始姿势"></p>
<p><img src="/2017/11/23/囚徒健身/6-3-2.jpg" alt="结束姿势"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>30s</td>
<td>1min</td>
<td>2min</td>
</tr>
</tbody>
</table>
<h2 id="第四式：半倒立撑">第四式：半倒立撑</h2>
<p><strong>动作：</strong><br>
找一堵墙，双手手掌平放在距离墙根约15—25厘米的地面上，双手与肩同宽。手臂尽量伸直，蹬起成靠墙倒立姿势（第三式）。你现在应该处于标准的靠墙倒立姿势——手臂伸直，身体收紧，背部略微向内弓，脚跟与墙壁轻轻接触。这是该动作的起始姿势（图113）。 然后弯曲肘部，使头部向地面方向下降一半高度。这是该动作的结束姿势（图114）。暂停一下，然后稳稳地推起身体，回到起始姿势。整个动作的运动幅度大约只有15 厘米。刚开始练习时不要误判距离，让身体降得太低。整组练习中保持平缓呼吸。</p>
<p><img src="/2017/11/23/囚徒健身/6-4-1.jpg" alt="半倒立撑"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X5</td>
<td>2X10</td>
<td>3X20</td>
</tr>
</tbody>
</table>
<h2 id="第五式：标准倒立撑">第五式：标准倒立撑</h2>
<p><strong>动作：</strong><br>
找一面墙，双手手掌平放在距离墙根约15—25厘米的地面上，双手与肩同宽。双膝曲，蹬起靠墙成倒立姿势。如果你从前几式一路练过来，那现在对此过程必然了如指掌。如果你已经找到了适合自己的上墙技巧，那也很好。重要的是培养肌肉，而不是上墙的方式。上墙之后，只有双脚脚跟与墙壁接触，背部略微向内弯曲成弓形，双臂伸直。这是该动作的起始姿势（图115）。弯曲肘部，直到头顶轻轻接触地板。这是该动作的结束姿势（图116）。使用“亲亲宝贝”的方法保护头部（参见第37页）。暂停1秒钟，然后推起身体，回到起始姿势。在所有倒立动作中都要通过肌肉控制身体，同时还要集中精神，以确保安全。尽量保持平缓呼吸。</p>
<p><img src="/2017/11/23/囚徒健身/6-5-1.jpg" alt="标准倒立撑"></p>
<p><strong>目标</strong></p>
<table>
<thead>
<tr>
<th>初级</th>
<th>中级</th>
<th>高级</th>
</tr>
</thead>
<tbody>
<tr>
<td>1X5</td>
<td>2X10</td>
<td>3X15</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 个人提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 健身 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希腊字母读音表]]></title>
      <url>/2017/11/14/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%AF%BB%E9%9F%B3%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1>希腊字母读音表</h1>
<table>
<thead>
<tr>
<th>大写</th>
<th>小写</th>
<th>英文</th>
<th>音标</th>
<th>注音</th>
</tr>
</thead>
<tbody>
<tr>
<td>Α</td>
<td>α</td>
<td>alpha</td>
<td>a:lf</td>
<td>阿尔法</td>
</tr>
<tr>
<td>Β</td>
<td>β</td>
<td>beta</td>
<td>bet</td>
<td>贝塔</td>
</tr>
<tr>
<td>Γ</td>
<td>γ</td>
<td>gamma</td>
<td>ga:m</td>
<td>伽马</td>
</tr>
<tr>
<td>Δ</td>
<td>δ</td>
<td>delta</td>
<td>delt</td>
<td>德尔塔</td>
</tr>
<tr>
<td>Ε</td>
<td>ε</td>
<td>epsilon</td>
<td>ep`silon</td>
<td>伊普西龙</td>
</tr>
<tr>
<td>Ζ</td>
<td>ζ</td>
<td>zeta</td>
<td>zat</td>
<td>截塔</td>
</tr>
<tr>
<td>Η</td>
<td>η</td>
<td>eta</td>
<td>eit</td>
<td>艾塔</td>
</tr>
<tr>
<td>Θ</td>
<td>θ</td>
<td>theta</td>
<td>θit</td>
<td>西塔</td>
</tr>
<tr>
<td>Ι</td>
<td>ι</td>
<td>iota</td>
<td>aiot</td>
<td>约塔</td>
</tr>
<tr>
<td>Κ</td>
<td>κ</td>
<td>kappa</td>
<td>kap</td>
<td>卡帕</td>
</tr>
<tr>
<td>∧</td>
<td>λ</td>
<td>lambda</td>
<td>lambd</td>
<td>兰布达</td>
</tr>
<tr>
<td>Μ</td>
<td>μ</td>
<td>mu</td>
<td>mju</td>
<td>缪</td>
</tr>
<tr>
<td>Ν</td>
<td>ν</td>
<td>nu</td>
<td>nju</td>
<td>纽</td>
</tr>
<tr>
<td>Ξ</td>
<td>ξ</td>
<td>xi</td>
<td>ksi</td>
<td>克西</td>
</tr>
<tr>
<td>Ο</td>
<td>ο</td>
<td>omicron</td>
<td>omik`ron</td>
<td>奥密克戎</td>
</tr>
<tr>
<td>∏</td>
<td>π</td>
<td>pi</td>
<td>pai</td>
<td>派</td>
</tr>
<tr>
<td>Ρ</td>
<td>ρ</td>
<td>rho</td>
<td>rou</td>
<td>肉</td>
</tr>
<tr>
<td>∑</td>
<td>σ</td>
<td>sigma</td>
<td>`sigma</td>
<td>西格马</td>
</tr>
<tr>
<td>Τ</td>
<td>τ</td>
<td>tau</td>
<td>tau</td>
<td>套</td>
</tr>
<tr>
<td>Υ</td>
<td>υ</td>
<td>upsilon</td>
<td>ju:p`sailon</td>
<td>宇普西龙</td>
</tr>
<tr>
<td>Φ</td>
<td>φ</td>
<td>phi</td>
<td>fai</td>
<td>佛爱</td>
</tr>
<tr>
<td>Χ</td>
<td>χ</td>
<td>chi</td>
<td>phai</td>
<td>西</td>
</tr>
<tr>
<td>Ψ</td>
<td>ψ</td>
<td>psi</td>
<td>psai</td>
<td>普西</td>
</tr>
<tr>
<td>Ω</td>
<td>ω</td>
<td>omega</td>
<td>o`miga</td>
<td>欧米伽</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常用算法总结]]></title>
      <url>/2017/11/06/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1>KMP算法</h1>
<p>KMP算法原理可以参考<a href="http://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="noopener">详解KMP算法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 找到返回起始位置，否则-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMPPatternMatch</span><span class="params">(String target,String pattern,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(target==<span class="keyword">null</span>||pattern==<span class="keyword">null</span>||pattern.length()==<span class="number">0</span>||pattern.length()&gt;target.length())&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i=start,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[] next=getNext(pattern);</span><br><span class="line">	<span class="keyword">while</span>(i&lt;target.length())&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==-<span class="number">1</span>||target.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">			i++;j++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j=next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j==pattern.length())&#123;</span><br><span class="line">			<span class="keyword">return</span> i-j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算next数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</span><br><span class="line">	<span class="keyword">int</span>[] next =<span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>,k=-<span class="number">1</span>;</span><br><span class="line">	next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;pattern.length()-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k==-<span class="number">1</span>||pattern.charAt(k)==pattern.charAt(j))&#123;</span><br><span class="line">			j++;k++;</span><br><span class="line">			<span class="keyword">if</span>(pattern.charAt(k)==pattern.charAt(j))&#123;</span><br><span class="line">				next[j]=next[k];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				next[j]=k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k=next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[北京信息科技大学邮编]]></title>
      <url>/2017/10/17/%E5%8C%97%E4%BA%AC%E4%BF%A1%E6%81%AF%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E9%82%AE%E7%BC%96/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/17/北京信息科技大学邮编/%E9%82%AE%E7%BC%96.png" alt="北京信息科技大学邮编"></p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-真题]]></title>
      <url>/2017/10/11/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E7%9C%9F%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1>美团点评</h1>
<h2 id="给定数位和的最大数">给定数位和的最大数</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于一个十进制数，它的数位和等于将它各位数字相加的到的和。比如231的数位和是6,3179的数位和是20.</span><br><span class="line">现知道一个十进制数的数位和等于s，且这个数不包含0，且任意相邻的数位是不同的。</span><br><span class="line">比如112或者102都不满足条件。求满足这样条件的最大数是多少</span><br><span class="line"></span><br><span class="line">输入：第一行包含一个整数s 1&lt;=s&lt;=42</span><br><span class="line"></span><br><span class="line">输出满足条件的最大整数。</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ol>
<li>位数越多，数字越大，所以每一位数尽可能小。因为相邻两个数不一样，所以每一位数只可能为1或者2。（证：如果有一位数是3，则把它拆成12，新数比原数大一位）</li>
<li>列出n=1——10，观察规律</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">21</td>
<td style="text-align:center">121</td>
<td style="text-align:center">212</td>
<td style="text-align:center">2121</td>
<td style="text-align:center">12121</td>
<td style="text-align:center">21212</td>
<td style="text-align:center">212121</td>
<td style="text-align:center">1212121</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>n&gt;2时，n+1对应的数m(n+1)视为n对应的数m(n)修改而来。观察可得如下规律
<ul>
<li>若m(n)首尾都为1，则m(n+1)为m(n)删掉首部的1，再在末尾加2</li>
<li>若m(n)首尾都为2，则m(n+1)为m(n)尾部加2</li>
<li>若m(n)首部为2，尾都为1，则m(n+1)为m(n)首部加1</li>
</ul>
</li>
</ol>
<p>这样就可以将该数字视为字符串处理，使用StringBuilder实现。时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner reader=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(reader.hasNextInt())&#123;</span><br><span class="line">			<span class="keyword">int</span> n=reader.nextInt();</span><br><span class="line">			System.out.println(maxNum(n));</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maxNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		StringBuilder sBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			sBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">			sBuilder.append(<span class="string">"2"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			sBuilder.append(<span class="string">"21"</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="keyword">char</span> head=sBuilder.charAt(<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">char</span> tail=sBuilder.charAt(sBuilder.length()-<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(head==<span class="string">'1'</span>&amp;&amp;tail==<span class="string">'1'</span>)&#123;</span><br><span class="line">					sBuilder=<span class="keyword">new</span> StringBuilder(sBuilder.subSequence(<span class="number">1</span>, sBuilder.length()));</span><br><span class="line">					sBuilder.append(<span class="string">'2'</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(head==<span class="string">'2'</span>&amp;&amp;tail==<span class="string">'2'</span>)&#123;</span><br><span class="line">					sBuilder.append(<span class="string">'1'</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(head==<span class="string">'2'</span>&amp;&amp;tail==<span class="string">'1'</span>)&#123;</span><br><span class="line">					sBuilder.insert(<span class="number">0</span>, <span class="string">'1'</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sBuilder.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="序列移动">序列移动</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">有一个长度为n的序列，其中的元素分别为1,2,3,...,n。接下来对这个数列进行一些操作。</span><br><span class="line">每一次选一个数，将它从序列中原来的位置去除并放在序列的最前面。求操作后的序列</span><br><span class="line"></span><br><span class="line">输入：第一行两个整数n，m，1&lt;=n,m,&lt;=10^5。接下来m行每行包含一个整数k，表示要把k放到序列的最前面。</span><br><span class="line"></span><br><span class="line">输出：从前往后输出序列中的每个元素，每个元素占一行。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">输入：</span><br><span class="line">5 3</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>难点：</p>
<ol>
<li>m个操作中有重复的数的情况</li>
<li>降低时间复杂度上</li>
</ol>
<p>思路：<br>
如果可以只记录被操作的数和操作的次序，则可能在常数时间复杂度下输出操作后序列。</p>
<ol>
<li>使用数组记录操作过的数的位置，则可在常数时间复杂度下输出未被操作的数的序列</li>
<li>单独记录已操作过的数，并根据操作顺序存放，则可在常数时间复杂度下输出操作过的数的序列</li>
</ol>
<p>解法1：<br>
以下算法虽然AC，但是使用了排序，时间复杂度并不是常数级别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner reader=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(reader.hasNextInt())&#123;</span><br><span class="line">			<span class="keyword">int</span> n=reader.nextInt();</span><br><span class="line">			<span class="keyword">int</span> m=reader.nextInt();</span><br><span class="line">			<span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">int</span>[] heads=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			TreeMap&lt;Integer, Integer&gt; tmheads=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">			HashMap&lt;Integer, Integer&gt; hmHeads=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> index=reader.nextInt()-<span class="number">1</span>;</span><br><span class="line">				nums[index]=-<span class="number">1</span>;</span><br><span class="line">				hmHeads.put(index, i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; hmlHeads=<span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(hmHeads.entrySet());</span><br><span class="line">			Collections.sort(hmlHeads,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer, Integer&gt; o1, Entry&lt;Integer, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(Entry&lt;Integer, Integer&gt; num:hmlHeads)&#123;</span><br><span class="line">				System.out.println(num.getKey()+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(nums[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">					System.out.println(i+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：<br>
使用长度为n的数组记录未操作的数<br>
使用长度为m的数组记录操作过的数<br>
使用hashmap存放多次操作的数的存放位置<br>
m次操作都可在常数时间内完成<br>
最后只要顺序输出两个数组中需要输出的数<br>
时间复杂度理论上为2(m+n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">		<span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line">		<span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[n+m];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			s[m+i] = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> c = scan.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">				s[m-map.get(c)] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(c, i);			</span><br><span class="line">			<span class="keyword">if</span>(s[m+c-<span class="number">1</span>] == <span class="number">0</span>)&#123;				</span><br><span class="line">				s[m-map.get(c)] = <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[m+c-<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">				s[m+c-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			s[m-i] = c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n+m);i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(s[i]);</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>今日头条</h1>
<h2 id="字符串重叠">字符串重叠</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串s和一个字符串列表的字典，如果字符串s包含字典中的字符串，</span><br><span class="line">就用&amp;lt;b&gt;和&amp;lt;/b&gt;标记，如果不同的子字符串重叠，就需要进行合并。</span><br><span class="line">例如：</span><br><span class="line">input：</span><br><span class="line">s=&quot;aaabbbccc&quot;</span><br><span class="line">dict=[&quot;aaa&quot;,&quot;aab&quot;,&quot;bc&quot;]</span><br><span class="line">output:</span><br><span class="line">&quot;&lt;b&gt;aaabbc&lt;/b&gt;c&quot;</span><br></pre></td></tr></table></figure>
<p>难点：在于会有位置重叠，需要合并。</p>
<p>思路：匹配dict中字符串在s中的起止位置，存入list中，按起始位置排序。这样只有相邻位置可能出现重叠</p>
<p>重点：</p>
<ol>
<li>使用<code>Collections.sort（）</code>方法排序list</li>
<li>使用<code>StringBuilder</code>进行字符串拼接</li>
<li>从后往前插入标记符号，这样前面的字符串起止位置不会变</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String s=<span class="string">"aaabbcc"</span>;</span><br><span class="line">		String[] dict=&#123;<span class="string">"aaa"</span>,<span class="string">"aab"</span>,<span class="string">"bc"</span>&#125;;</span><br><span class="line">		Solution so=<span class="keyword">new</span> Solution();</span><br><span class="line">		System.out.println(so.addBoldTag(s, dict));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//新建一个类用于存储起止位置。该类需要实现Comparable接口</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tag</span>&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> start;</span><br><span class="line">		<span class="keyword">int</span> end;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> start-t.start;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">addBoldTag</span><span class="params">(String s,String[] dict)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		List&lt;Tag&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String str : dict) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> index=s.indexOf(str);</span><br><span class="line">			<span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">				Tag tag=<span class="keyword">new</span> Tag();</span><br><span class="line">				tag.start=index;</span><br><span class="line">				tag.end=index+str.length();</span><br><span class="line">				list.add(tag);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Collections.sort(list);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			Tag tag1=list.get(i);</span><br><span class="line">			Tag tag2=list.get(i+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(tag2.start&lt;=tag1.end)&#123;</span><br><span class="line">				<span class="keyword">if</span>(tag2.end&gt;=tag1.end)&#123;</span><br><span class="line">					tag1.end=tag2.end;</span><br><span class="line">				&#125;</span><br><span class="line">				list.remove(i+<span class="number">1</span>);</span><br><span class="line">				i--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//从后往前插入标志符号</span></span><br><span class="line">		StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			Tag aTag=list.get(i);</span><br><span class="line">			sb.insert(aTag.end, <span class="string">"&lt;\\b&gt;"</span>);</span><br><span class="line">			sb.insert(aTag.start, <span class="string">"&lt;b&gt;"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		String line=sb.toString();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> line;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手串颜色">手串颜色</h2>
<p>CodeFalling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">有人向你订购了一条包含n个珠子的手串，每个珠子要么无色，要么涂有若干种颜色。</span><br><span class="line">为了使手串的色彩不单调，</span><br><span class="line">要求手串上的任意一种颜色（不包含无色）在任意连续的m个珠子里至多出现一次（这是一个环形手串）。</span><br><span class="line">手串上的颜色共有c种。</span><br><span class="line">现按顺时针告诉你n个珠子上所包含的颜色分别有哪些。</span><br><span class="line">请判断该手串上有多少种颜色不符合要求。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">第一行为n m c三个数，用空格隔开，接下来的n行每行第一个数num表示第i个珠子有多少种颜色。接下来依次读入num个数字，每个数字表示这个珠子上的一种颜色。</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">一个非负整数，表示该手链上有多少种颜色不符合要求。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">输入</span><br><span class="line">5 2 3</span><br><span class="line">3 1 2 3</span><br><span class="line">0</span><br><span class="line">2 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>难点：判断窗口需要在一个环上移动</p>
<p>思路：</p>
<ol>
<li>记录每个颜色出现的位置，用下一次出现的位置与上一次的比较。</li>
<li>遍历两次手串，以覆盖环形的情况</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shouchuan2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> n,m,c;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Shouchuan2 sc2=<span class="keyword">new</span> Shouchuan2();</span><br><span class="line">		sc2.shouchuancolors();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouchuancolors</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">		BufferedReader bReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		String line=bReader.readLine();</span><br><span class="line">		n=Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">0</span>]);</span><br><span class="line">		m=Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">1</span>]);</span><br><span class="line">		c=Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">2</span>]);</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; chuan=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			line=bReader.readLine();</span><br><span class="line">			String[] nums=line.split(<span class="string">" "</span>);</span><br><span class="line">			List&lt;Integer&gt; zhuzi=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String numstr :nums) &#123;</span><br><span class="line">				zhuzi.add(Integer.parseInt(numstr));</span><br><span class="line">			&#125;</span><br><span class="line">			chuan.add(zhuzi);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] colors=<span class="keyword">new</span> <span class="keyword">int</span>[c];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)&#123;</span><br><span class="line">			colors[i]=-<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n&lt;m)&#123;</span><br><span class="line">			System.out.println(<span class="string">"0"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chuan.size()-<span class="number">1</span>;i++) &#123;</span><br><span class="line">			List&lt;Integer&gt; zhuzi=chuan.get(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;zhuzi.size();j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> color=zhuzi.get(j);</span><br><span class="line">				countColor(colors, color, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chuan.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			List&lt;Integer&gt; zhuzi=chuan.get(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;zhuzi.size();j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> color=zhuzi.get(j);</span><br><span class="line">				countColor(colors, color, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : colors) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==-<span class="number">2</span>)&#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">countColor</span><span class="params">(<span class="keyword">int</span>[] colors,<span class="keyword">int</span> color,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(colors[color-<span class="number">1</span>]==-<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(colors[color-<span class="number">1</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">			colors[color-<span class="number">1</span>]=i;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(colors[color-<span class="number">1</span>]&lt;i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(colors[color-<span class="number">1</span>]-i&lt;m)&#123;</span><br><span class="line">				colors[color-<span class="number">1</span>]=-<span class="number">2</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				colors[color-<span class="number">1</span>]=i;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(colors[color-<span class="number">1</span>]&gt;=i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(colors[color-<span class="number">1</span>]+n-i&lt;m)&#123;</span><br><span class="line">				colors[color-<span class="number">1</span>]=-<span class="number">2</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				colors[color-<span class="number">1</span>]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 真题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-排序算法]]></title>
      <url>/2017/09/28/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1>参考资料</h1>
<p><a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a><br>
<a href="http://www.cnblogs.com/eniac12/p/5329396.html#s3" target="_blank" rel="noopener">常用排序算法总结</a><br>
<a href="https://github.com/it-interview/easy-job" target="_blank" rel="noopener">2017互联网求职面试知识复习</a></p>
<h1>排序算法</h1>
<table>
<thead>
<tr>
<th>插入排序</th>
<th>选择排序</th>
<th>交换排序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序<br>希尔排序</td>
<td>简单选择排序<br>堆排序</td>
<td>冒泡排序<br>快速排序</td>
<td>归并排序</td>
<td>基数排序</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>是否稳定</th>
<th>平均</th>
<th>最好</th>
<th>最坏</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>稳定</td>
<td>n^2</td>
<td>n</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>n^1.3</td>
<td>n</td>
<td>n^s 1&lt;s&lt;2</td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td>不稳定</td>
<td>n^2</td>
<td>n^2</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>n^2</td>
<td>n</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>nlogn</td>
<td>nlogn</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>d(n+r)</td>
<td>d(n+r)</td>
<td>d(n+r)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="插入排序-稳定">插入排序 <strong>稳定</strong></h2>
<p>原理：从有序序列中选择合适的位置进行插入</p>
<p>复杂度：最好 - 最坏 - 平均 O(n) - O(n^2) - O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertiontionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> ==a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[i]; <span class="comment">// 暂存</span></span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">			a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+<span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序-缩小增量排序-不稳定">希尔排序(缩小增量排序) <strong>不稳定</strong></h2>
<p>按步长进行分组，组内直接插入，缩小增量再次进行此步骤，增量为1时相当于一次直接插入。</p>
<p>复杂度：最好O(n) - 最坏O(n^s 1&lt;s&lt;2) - 平均O(n^1.3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = a.length/<span class="number">2</span>; d &gt; <span class="number">0</span>; d/=<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 内部直接插入</span></span><br><span class="line">			<span class="keyword">int</span> temp = a[i];</span><br><span class="line">			<span class="keyword">int</span> j = i - d;</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">				a[j+d] = a[j];</span><br><span class="line">				j -= d;</span><br><span class="line">			&#125;</span><br><span class="line">			a[j+d] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-不稳定">选择排序 <strong>不稳定</strong></h2>
<p>原理：每次从无序序列选择一个最小的</p>
<p>复杂度：最好O(n^2) - 最坏O(n^2) - 平均O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[k]) &#123;</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = a[k];</span><br><span class="line">			a[k] = a[i];</span><br><span class="line">			a[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<p>原理：利用堆的特性</p>
<p>复杂度：O(nlogn) [平均 - 最好 - 最坏]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	buildMaxHeap(a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">		a[<span class="number">0</span>] = a[i];</span><br><span class="line">		a[i] = temp;</span><br><span class="line">		adjustHeap(a, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		adjustHeap(a, a.length, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> size, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> right = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> largest = parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; size &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">		largest = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right &lt; size &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">		largest = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent != largest) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[parent];</span><br><span class="line">		a[parent] = a[largest];</span><br><span class="line">		a[largest] = temp;</span><br><span class="line">		adjustHeap(a, size, largest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序-稳定">冒泡排序 <strong>稳定</strong></h2>
<p>原理：相邻两个元素比较大小进行交换，一趟冒泡后会有一个元素到达最终位置</p>
<p>复杂度：最好 - 最坏 - 平均 O(n) - O(n^2) - O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>] = temp;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-不稳定">快速排序 <strong>不稳定</strong></h2>
<p>原理：分治+递归</p>
<p>复杂度：最好O(nlgn) - 最坏O(n^2) - 平均O(nlgn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = partition(a, low, high);</span><br><span class="line">		quickSort(a, low, mid - <span class="number">1</span>);</span><br><span class="line">		quickSort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = a[low];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= pivot) &#123;</span><br><span class="line">			high--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[low] = a[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= pivot) &#123;</span><br><span class="line">			low++;</span><br><span class="line">		&#125;</span><br><span class="line">		a[high] = a[low];</span><br><span class="line">	&#125;</span><br><span class="line">	a[low] = pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选取pivot的方式：固定基准元 随机基准 三数取中</p>
<p>快排的优化：针对随机数组+有序数组+重复数组</p>
<p>1.当待排序序列的长度分割到一定大小后，使用插入排序&lt;三数取中+插入排序&gt;：效率提高一些，但是都解决不了重复数组的问题。</p>
<p>2.在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割<br>
&lt;三数取中+插排+聚集相同元素&gt;</p>
<h2 id="归并排序-稳定">归并排序 <strong>稳定</strong></h2>
<p>原理：两个有序序列的合并，方法：分治 + 递归</p>
<p>复杂度：最好O(nlgn) - 最坏O(nlgn) - 平均O(nlgn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="comment">//左边</span></span><br><span class="line">		mergeSort(a, low, mid);</span><br><span class="line">		<span class="comment">//右边</span></span><br><span class="line">		mergeSort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">		<span class="comment">//有序序列归并</span></span><br><span class="line">		merge(a, low, mid, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 左指针</span></span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="comment">// 右指针</span></span><br><span class="line">	<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 临时数组指针</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">			temp[k++] = a[i++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp[k++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左边剩余</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">		temp[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//右边剩余</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">		temp[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 倒出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; temp.length; t++) &#123;</span><br><span class="line">		a[t + low] = temp[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序-稳定">基数排序 <strong>稳定</strong></h2>
<p>原理：分配加收集</p>
<p>复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 基数</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 桶中的数据统计</span></span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line">		<span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按照从低位到高位的顺序执行排序过程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= digit; i++) &#123;</span><br><span class="line">			<span class="comment">// 清空桶中的数据统计</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; radix; j++) &#123;</span><br><span class="line">				count[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 统计各个桶将要装入的数据个数</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= a.length; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> index = getDigit(a[j], i);</span><br><span class="line">				count[index]++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// count[i]表示第i个桶的右边界索引</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; radix; j++) &#123;</span><br><span class="line">				count[j] = count[j] + count[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将数据依次装入桶中</span></span><br><span class="line">            <span class="comment">// 这里要从右向左扫描，保证排序稳定性</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = a.length-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">int</span> index = getDigit(a[j], i);</span><br><span class="line">				bucket[count[index] - <span class="number">1</span>] = a[j];</span><br><span class="line">				count[index]--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 取出，此时已是对应当前位数有序的表</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">				a[j] = bucket[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取x的第d位的数字，其中最低位d=1</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		String div = <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">while</span> (d &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			div += <span class="string">"0"</span>;</span><br><span class="line">			d--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x/Integer.parseInt(div) % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>排序算法详解</h1>
<p>排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里主要讨论内部排序。</p>
<p><img src="/2017/09/28/面试笔试题-排序算法/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.jpg" alt="八大排序算法"></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="简单插入排序">简单插入排序</h3>
<p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p><img src="/2017/09/28/面试笔试题-排序算法/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序过程"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以</p>
<blockquote>
<p>插入排序是<strong>稳定</strong>排序。<br>
时间复杂度<strong>O（n^2)</strong> ,空间复杂度O（1）。<br>
插入排序不适合对于数据量比较大的排序应用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序。时间复杂度O（n^2),空间复杂度O（1），稳定</span></span><br><span class="line"><span class="comment"> * 升序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSorting(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> n=a[i];</span><br><span class="line">		<span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;n)&#123;<span class="comment">//升序。改为a[j]&lt;n则为降序</span></span><br><span class="line">			a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+<span class="number">1</span>]=n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分插入排序">二分插入排序</h3>
<p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序。<br>
当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<p>最差时间复杂度 ---- O(n^2)<br>
最优时间复杂度 ---- O(nlogn)<br>
平均时间复杂度 ---- O(n^2)<br>
所需辅助空间 ------ O(1)</p>
<h3 id="希尔排序">希尔排序</h3>
<p>希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。</p>
<p><img src="/2017/09/28/面试笔试题-排序算法/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 最优复杂度O(n),平均复杂度跟步长选取有关</span></span><br><span class="line"><span class="comment"> * 不稳定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellShorting(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">	<span class="keyword">int</span> n=a.length;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (h &lt;= n)                          <span class="comment">// 生成初始增量</span></span><br><span class="line">		&#123;</span><br><span class="line">				h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">				&#123;</span><br><span class="line">						<span class="keyword">int</span> j = i - h;</span><br><span class="line">						<span class="keyword">int</span> get = a[i];</span><br><span class="line">						<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; get)</span><br><span class="line">						&#123;</span><br><span class="line">								a[j + h] = a[j];</span><br><span class="line">								j = j - h;</span><br><span class="line">						&#125;</span><br><span class="line">						a[j + h] = get;</span><br><span class="line">				&#125;</span><br><span class="line">				h = (h - <span class="number">1</span>) / <span class="number">3</span>;                    <span class="comment">// 递减增量</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序">选择排序</h2>
<h3 id="简单选择排序">简单选择排序</h3>
<p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p>
<p>选择排序的代码如下：</p>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[北大中文核心期刊]]></title>
      <url>/2017/09/26/%E5%8C%97%E5%A4%A7%E4%B8%AD%E6%96%87%E6%A0%B8%E5%BF%83%E6%9C%9F%E5%88%8A/</url>
      <content type="html"><![CDATA[<p><a href="http://www.seek68.cn/bdhxqkml2014.htm" target="_blank" rel="noopener">北大中文核心期刊</a></p>
<p><img src="/2017/09/26/北大中文核心期刊/hexin.JPG" alt="计算机核心期刊"></p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-经典题型]]></title>
      <url>/2017/09/26/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1>岛屿的数量</h1>
<p>Given a 2d grid map of '1’s (land) and’0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<blockquote>
<p>Example 1:<br>
11110<br>
11010<br>
11000<br>
00000<br>
Answer: 1</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
11000<br>
11000<br>
00100<br>
00011<br>
Answer: 3</p>
</blockquote>
<p>给定的一个二维网格的地图（’1’（陆地）和0（水）），计数岛的数量。岛屿是四面环水，是由相邻的陆地水平或垂直连接而形成的。你可以假设该网格的所有四个边都被水包围。</p>
<p>采用深度优先遍历，把访问过的改为‘0’，继续遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 岛屿的数量 </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span></span><br><span class="line">				|| grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> rows = grid.length;</span><br><span class="line">		<span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">				<span class="comment">// 注意char</span></span><br><span class="line">				<span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					dfsSearch(grid, i, j, rows, cols);</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="keyword">return</span> count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每遇到'1'后, 开始向四个方向 递归搜索. 搜到后变为'0',</span></span><br><span class="line">	<span class="comment">// 因为相邻的属于一个island. 然后开始继续找下一个'1'.</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsSearch</span><span class="params">(<span class="keyword">char</span>[][] grid,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 也可以才用一个visited数组，标记遍历过的岛屿</span></span><br><span class="line">		grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">		dfsSearch(grid, i + <span class="number">1</span>, j, rows, cols);</span><br><span class="line">		dfsSearch(grid, i - <span class="number">1</span>, j, rows, cols);</span><br><span class="line">		dfsSearch(grid, i, j + <span class="number">1</span>, rows, cols);</span><br><span class="line">		dfsSearch(grid, i, j - <span class="number">1</span>, rows, cols);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>最大公约数</h1>
<p>参考自：<a href="http://www.cnblogs.com/hexiaochun/archive/2012/09/03/2668250.html" target="_blank" rel="noopener">java 算法基础之一寻找最大公约数</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreatestCommonDivisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a=<span class="number">60</span>;</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">45</span>;</span><br><span class="line">		System.out.println(getGCD(a, b));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">			<span class="keyword">return</span> getGCD(b, a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == b) &#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isTwo(a)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isTwo(b)) &#123;</span><br><span class="line">				<span class="keyword">return</span> getGCD(a / <span class="number">2</span>, b / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> getGCD(a / <span class="number">2</span>, b);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isTwo(b)) &#123;</span><br><span class="line">				<span class="keyword">return</span> getGCD(a, b / <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> getGCD(b, a - b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTwo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == a % <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>海伦公式</h1>
<p>假设在平面内，有一个三角形，边长分别为$a$ 、$b$ 、$c$ ，三角形的面积$S$ 可由以下公式求得：<br>
$$S=\sqrt{p(p-a)(p-b)(p-c)}$$</p>
<p>而公式里的p为半周长：<br>
$$p=(a+b+c)/2$$</p>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经典题型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-机器学习]]></title>
      <url>/2017/09/24/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1>过拟合与欠拟合</h1>
<p><a href="http://blog.csdn.net/hurry0808/article/details/78148756" target="_blank" rel="noopener">差与方差，欠拟合与过拟合</a></p>
<h1>SVM</h1>
<p><a href="http://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">支持向量机通俗导论（理解SVM的三层境界）</a></p>
<h1>决策树、SVM、AdaBoost方法的比较</h1>
<p>参考内容见<a href="http://blog.csdn.net/sinat_32547403/article/details/72911193" target="_blank" rel="noopener">CSDN博客</a></p>
<h1>交叉熵与相对熵（KL距离）</h1>
<p>作者：知乎用户<br>
链接：<a href="https://www.zhihu.com/question/41252833/answer/108777563" target="_blank" rel="noopener">https://www.zhihu.com/question/41252833/answer/108777563</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>熵的本质是香农信息量()的期望。现有关于样本集的2个概率分布p和q，其中p为真实分布，q非真实分布。按照真实分布p来衡量识别一个样本的所需要的编码长度的期望(即平均编码长度)为：H§=。如果使用错误分布q来表示来自真实分布p的平均编码长度，则应该是：H(p,q)=。因为用q来编码的样本来自分布p，所以期望H(p,q)中概率是p(i)。H(p,q)我们称之为“交叉熵”。比如含有4个字母(A,B,C,D)的数据集中，真实分布p=(1/2, 1/2, 0, 0)，即A和B出现的概率均为1/2，C和D出现的概率都为0。计算H§为1，即只需要1位编码即可识别A和B。如果使用分布Q=(1/4, 1/4, 1/4, 1/4)来编码则得到H(p,q)=2，即需要2位编码来识别A和B(当然还有C和D，尽管C和D并不会出现，因为真实分布p中C和D出现的概率为0，这里就钦定概率为0的事件不会发生啦)。可以看到上例中根据非真实分布q得到的平均编码长度H(p,q)大于根据真实分布p得到的平均编码长度H§。事实上，根据Gibbs’ inequality可知，H(p,q)&gt;=H§恒成立，当q为真实分布p时取等号。我们将由q得到的平均编码长度比由p得到的平均编码长度多出的bit数称为“相对熵”：D(p||q)=H(p,q)-H§=，其又被称为KL散度(Kullback–Leibler divergence，KLD) Kullback–Leibler divergence。它表示2个函数或概率分布的差异性：差异越大则相对熵越大，差异越小则相对熵越小，特别地，若2者相同则熵为0。注意，KL散度的非对称性。比如TD-IDF算法就可以理解为相对熵的应用：词频在整个语料库的分布与词频在具体文档中分布之间的差异性。交叉熵可在神经网络(机器学习)中作为损失函数，p表示真实标记的分布，q则为训练后的模型的预测标记分布，交叉熵损失函数可以衡量p与q的相似性。交叉熵作为损失函数还有一个好处是使用sigmoid函数在梯度下降时能避免均方误差损失函数学习速率降低的问题，因为学习速率可以被输出的误差所控制。PS：通常“相对熵”也可称为“交叉熵”，因为真实分布p是固定的，D(p||q)由H(p,q)决定。当然也有特殊情况，彼时2者须区别对待。</p>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-Java]]></title>
      <url>/2017/09/24/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-Java/</url>
      <content type="html"><![CDATA[<h1>Java中线程安全的类与相关问题</h1>
<p>不安全的集合：ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等<br>
可以使用Collections提供的类方法把这些集合包装为线程安全的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; List&lt;T&gt; synchronizedCollection(List&lt;T&gt; list)</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedCollection(Map&lt;K,V&gt; m)</span><br><span class="line">static &lt;T&gt; Set&lt;T&gt; synchronizedCollection(Set&lt;T&gt; s)</span><br></pre></td></tr></table></figure>
<p>线程安全的集合类：</p>
<ol>
<li>以Concurrent开头的集合类,如ConcurrentHashMap、ConcurrentSkipListMap</li>
<li>以CopyOnWrite开头的集合类,如CopyOnWriteArrayList</li>
</ol>
<p>相关问题：</p>
<ol>
<li>hashtable跟hashmap的区别<br>
hashtable是线程安全的,即hashtable的方法都提供了同步机制；hashmap不是线程安全的,即不提供同步机制 ；hashtable不允许插入空值,hashmap允许。</li>
<li>多线程并发修改一个集合怎么办<br>
用老的Vector/Hashtable类</li>
<li>StringBuffer是线程安全的，StringBuilder是线程不安全的</li>
</ol>
<h1>java基础内容面试题(一)</h1>
<ol>
<li>问题：如果main方法被声明为private会怎样？<br>
答案：能正常编译，但运行的时候会提示”main方法不是public的”.</li>
<li>问题：Java里的传引用和传值的区别是什么？<br>
答案：传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝.</li>
<li>问题：如果要重写一个对象的equals方法，还要考虑什么？<br>
答案：hashCode.</li>
<li>问题：Java的”一次编写，处处运行”是如何实现的？<br>
答案：Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。</li>
<li>问题：说明一下public static void main(String args[])这段声明里每个关键字的作用？<br>
答案：public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为public.static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。void: main方法没有返回值。String是命令行传进参数的类型，args是指命令行传进的字符串数组。</li>
<li>问题：==与equals的区别<br>
答案：==比较两个对象在内存里是不是同一个对象，就是说在内存里的存储位置一致。两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方 .<br>
==比较的是引用而equals方法比较的是内容。public boolean equals(Object obj) 这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,这个时候和==是等价的。String, BitSet, Date, 和File都对equals方法进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">运行：</span><br><span class="line">public class EqualsTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String s1 = “abc”;</span><br><span class="line">String s2 = s1;</span><br><span class="line">String s5 = “abc”;</span><br><span class="line">String s3 = new String(“abc”);</span><br><span class="line">String s4 = new String(“abc”);</span><br><span class="line">System.out.println(“== comparison : ” + (s1 == s5));</span><br><span class="line">System.out.println(“== comparison : ” + (s1 == s2));</span><br><span class="line">System.out.println(“Using equals method : ” + s1.equals(s2));</span><br><span class="line">System.out.println(“== comparison : ” + s3 == s4);</span><br><span class="line">System.out.println(“Using equals method : ” + s3.equals(s4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">== comparison : true</span><br><span class="line">== comparison : true</span><br><span class="line">Using equals method : true</span><br><span class="line">== comparison : false</span><br><span class="line">Using equals method :true</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>问题：如果去掉了main方法的static修饰符会怎样？<br>
答案：程序能正常编译。运行时会抛NoSuchMethodError异常。</li>
<li>问题：为什么Oracle type4驱动被称作瘦驱动？<br>
答案：oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的，可以在运行时由浏览器下载，不依赖任何客户端 的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。</li>
<li>问题：介绍一下finalize方法<br>
答案： final: 常量声明。 finally: 处理异常。 finalize: 帮助进行垃圾回收。<br>
final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>
finally是异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>
finalize是方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li>
<li>问题：什么是Java API？<br>
答案：Java API是大量软件组件的集合，它们提供了大量有用的功能，比如GUI组件。</li>
<li>问题：GregorianCalendar类是什么东西？<br>
答案：GregorianCalendar提供了西方传统日历的支持。</li>
<li>问题：ResourceBundle类是什么?<br>
答案：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。</li>
<li>问题：为什么Java里没有全局变量?<br>
答案：全局变量是全局可见的，Java不支持全局可见的变量，因为：全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突。</li>
<li>问题：如何将String类型转化成Number类型？<br>
答案：Integer类的valueOf方法可以将String转成Number。下面是代码示例：<br>
String numString = “1000”;<br>
int id=Integer.valueOf(numString).intValue();</li>
<li>问题：SimpleTimeZone类是什么?<br>
答案：SimpleTimeZone提供公历日期支持。</li>
<li>问题：while循环和do循环有什么不同？<br>
答案：while结构在循环的开始判断下一个迭代是否应该继续。do/while结构在循环的结尾来判断是否将继续下一轮迭代。do结构至少会执行一次循环体。</li>
<li>问题：Locale类是什么？<br>
答案：Locale类用来根据语言环境来动态调整程序的输出。</li>
<li>问题：面向对象编程的原则是什么?<br>
答案：主要有三点，多态，继承和封装。</li>
</ol>
<p>#	java基础内容面试题(二)</p>
<ol>
<li>问题：介绍下继承的原则<br>
答案：继承使得一个对象可以获取另一个对象的属性。使用继承可以让已经测试完备的功能得以复用，并且可以一次修改，所有继承的地方都同时生效。</li>
<li>问题：什么是隐式的类型转化?<br>
答案：隐式的类型转化就是简单的一个类型赋值给另一个类型，没有显式的告诉编译器发生了转化。并不是所有的类型都支持隐式的类型转化。<br>
代码示例：<br>
int i = 1000;<br>
long j = i; //Implicit casting</li>
<li>问题：sizeof是Java的关键字吗?<br>
答案：不是。</li>
<li>问题：native方法是什么?<br>
答案：native方法是非Java代码实现的方法。</li>
<li>问题：在System.out.println()里面,System, out, println分别是什么?<br>
答案：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。</li>
<li>问题：多态是什么？<br>
答案：简单来说，多态是指一个名字多种实现。多态使得一个实体通过一个通用的方式来实现不同的操作。具体的操作是由实际的实现来决定的。多态在Java里有三种表现方式：方法重载、通过继承实现方法重写、通过Java接口进行方法重写。</li>
<li>问题：显式的类型转化是什么?<br>
答案：显式的类型转化是明确告诉了编译器来进行对象的转化。<br>
代码示例：<br>
long i = 700.20;<br>
int j = (int) i; //Explicit casting</li>
<li>问题：什么是Java虚拟机?<br>
答案：Java虚拟机是能移植到不同硬件平台上的软件系统。</li>
<li>问题：类型向下转换是什么?<br>
答案：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。</li>
<li>问题：Java的访问修饰符是什么?<br>
答案：访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含：a)public: 所有类都可以访问b) protected: 同一个包内以及所有子类都可以访问 c)private: 只有归属的类才能访问d)默认: 归属类及相同包下的子类可以访问。</li>
<li>问题：所有类的父类是什么？<br>
答案：Object.</li>
<li>问题：Java的基本类型有哪些?<br>
答案：byte,char, short, int, long, float, double, boolean。</li>
<li>问题：静态类型有什么特点?<br>
答案：静态变量是和类绑定到一起的，而不是类的实例对象。每一个实例对象都共享同样一份静态变量。也就是说，一个类的静态变量只有一份，不管它有多少个对象。类变量或者说静态变量是通过static这个关键字来声明的。类变量通常被用作常量。静态变量通常通过类名字来进行访问。当程序运行的时候这个变量就会创建直到程序结束后才会被销毁。类变量的作用域和实例变量是一样的。它的初始值和成员变量也是一样的，当变量没被初始化的时候根据它的数据类型，会有一个默认值。类似的，静态方法是属于类的方法，而不是类对象，它的调用并不作用于类对象，也不需要创建任何的类实例。静态方法本身就是final的，因为重写只会发生在类实例上，静态方法是和类绑定在一起的，不是对象。父类的静态方法会被子类的静态方法屏蔽，只要原来方法没有声明为final。<br>
非静态方法不能重写静态方法，也就是说，你不能在子类中把一个静态方法改成实例方法。非静态变量在每一个对象实例上都有单独的一份值。</li>
<li>问题：&amp;操作符和&amp;&amp;操作符有什么区别?<br>
答案：当一个&amp;表达式在求值的时候，两个操作数都会被求值，&amp;&amp;更像是一个操作符的快捷方式。当一个&amp;&amp;表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为false,第二个操作数就不会被求值。</li>
<li>问题：Java是如何处理整型的溢出和下溢的?<br>
答案：Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。</li>
<li>问题：public static void写成static public void会怎样？<br>
答案：程序正常编译及运行。</li>
<li>问题：声明变量和定义变量有什么不同？<br>
答案：声明变量我们只提供变量的类型和名字，并没有进行初始化。定义包括声明和初始化两个阶段String s;只是变量声明，String s = new String(“bob”); 或者String s = “bob”;是变量定义。</li>
<li>问题：Java支持哪种参数传递类型?<br>
答案：Java参数都是进行传值。对于对象而言，传递的值是对象的引用，也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。</li>
<li>问题：对象封装的原则是什么?<br>
答案：封装是将数据及操作数据的代码绑定到一个独立的单元。这样保障了数据的安全，防止外部代码的错误使用。对象允许程序和数据进行封装，以减少潜在的干涉。对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问。</li>
<li>问题：你怎么理解变量？<br>
答案：变量是一块命名的内存区域，以便程序进行访问。变量用来存储数据，随着程序的执行，存储的数据也可能跟着改变。</li>
</ol>
<p>#	java基础内容面试题(三)</p>
<ol>
<li>问题：数值提升是什么?<br>
答案：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中，byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。</li>
<li>问题：Java的类型转化是什么?<br>
答案：从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个是显式的，一个是隐式的。</li>
<li>问题：main方法的参数里面，字符串数组的第一个参数是什么?<br>
答案：数组是空的，没有任何元素。不像C或者C++，第一个元素默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空,但不是null。</li>
<li>问题：怎么判断数组是null还是为空?<br>
答案：输出array.length的值，如果是0,说明数组为空。如果是null的话，会抛出空指针异常。</li>
<li>问题：程序中可以允许多个类同时都拥有main方法吗?<br>
答案：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。</li>
<li>问题：静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？<br>
答案：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。</li>
<li>问题：一个类能拥有多个main方法吗？<br>
答案：可以，但只能有一个main方法拥有以下签名：<br>
public static void main(String[] args) {}<br>
否则程序将无法通过编译。编译器会警告你main方法已经存在。</li>
<li>问题：简单的介绍下JVM是如何工作的?<br>
答案：JVM是一台抽象的计算机，就像真实的计算机那样，它们会先将.java文件编译成.class文件（.class文件就是字节码文件）,然后用它的解释器来加载字节码。</li>
<li>问题：如果原地交换两个变量的值？<br>
答案：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。<br>
代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a=5,b=10;a=a+b; b=a-b; a=a-b;</span><br><span class="line">使用异或操作也可以交换。第一个方法还可能会引起溢出。</span><br><span class="line">异或的方法如下：</span><br><span class="line">int a=5,b=10;a=a+b; b=a-b; a=a-b;</span><br><span class="line">int a = 5; int b = 10;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>问题：什么是数据的封装?<br>
答案：数据封装的一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性,它其实就是一种隐藏数据的方式。</li>
<li>问题：什么是反射API？它是如何实现的？<br>
答案：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field, Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。</li>
<li>问题：JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？<br>
答案：是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象。</li>
<li>问题：虚拟内存是什么?<br>
答案：虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。</li>
<li>问题：方法可以同时即是static又是synchronized的吗?<br>
答案：可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。<br>
这样做等于：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">synchronized(XYZ.class) &#123;</span><br><span class="line">&#125;</span><br><span class="line">15)	问题：String和StringTokenizer的区别是什么？</span><br><span class="line">答案：StringTokenizer是一个用来分割字符串的工具类。</span><br><span class="line">StringTokenizer st = new StringTokenizer(“Hello World”);</span><br><span class="line">while (st.hasMoreTokens()) &#123;</span><br><span class="line">System.out.println(st.nextToken());</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>
<ol start="16">
<li>问题：transient变量有什么特点?<br>
答案：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</li>
<li>问题：哪些容器使用Border布局作为它们的默认布局?<br>
答案：Window, Frame, Dialog。</li>
<li>问题：怎么理解什么是同步?<br>
答案：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另一个线程也在使用或者更新它的值。同步避免了脏数据的产生。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对方法进行同步：</span><br><span class="line">public synchronized void Method1 () &#123;</span><br><span class="line">// Appropriate method-related code.</span><br><span class="line">&#125;</span><br><span class="line">在方法内部对代码块进行同步：</span><br><span class="line">public myFunction ()&#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">// Synchronized code here.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="19">
<li>问题：Vector和ArrayList、LinkedList区别？<br>
答案：LinkedList内部以链表形式存储数据，ArrayList内部以数组形式存储数据。Vector同ArrayList，不过它与ArrayList比较起来是thread-safe的。</li>
</ol>
<ol start="20">
<li>问题：Hashtable和HashMap之间的区别？<br>
答案：Hashtable是继承了Dictionary，是线程安全的。<br>
HashMap实现了Map接口，不是线程安全的。</li>
</ol>
<p>#	java基础内容面试题(四)</p>
<ol>
<li>问题：如何保证线程安全的？<br>
答案：每个修改容器中数据的操作都是同步的（synchronized），因此保证了线程安全。</li>
<li>问题：String、StringBuffer，StringBuilder之间区别。<br>
答案：String是长度不可变的，StringBuffer和StringBuilder长度都是可以变化的。StringBuffer是线程安全的，StringBuilder不是线程安全的。</li>
<li>问题：AnonymousInnerClass(匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)<br>
答案：匿名的内部类是没有名字的内部类。不能extends(继承)其它类，但一个内部类可以作为一个接口，由另一个内部类实现。</li>
<li>问题：StaticNestedClass和InnerClass的不同<br>
答案：NestedClass（一般是C<ins>的说法），InnerClass(一般是JAVA的说法)。Java内部类与C</ins>嵌套类最大的不同就在于是否有指向外部的引用上。<br>
注：静态内部类（InnerClass）意味着：a)创建一个static内部类的对象，不需要一个外部类对象b)不能从一个static内部类的一个对象访问一个外部类对象。</li>
<li>问题：抽象类(abstract class)和接口(interface)有什么区别?<br>
答案：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>
接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义所有这种接口的方法。然后可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</li>
<li>问题：Java中的异常处理机制的简单原理和应用。<br>
答案：当Java程序违反了Java的语义规则时，Java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况：一种是Java类库内置的语义检查。例如数组下标越界时会引发IndexOutOfBoundsException，访问null的对象时会引发NullPointerException。另一种情况是Java允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是Java.lang.Throwable的子类。</li>
<li>问题：sleep()和wait()有什么区别?<br>
答案：sleep()是线程类Thread的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复，调用sleep不会释放对象锁。<br>
wait()是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li>
<li>问题：String是最基本的数据类型吗?<br>
答案：String不是基本数据类型，基本数据类型包括byte、int、char、long、float、double、boolean和short。 Java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。</li>
<li>问题：接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承实体类?<br>
答案：接口可以继承接口。抽象类可以实现接口。抽象类可继承实体类，但前提是实体类必须有明确的构造函数。</li>
<li>问题：Java有没有goto?<br>
答案：goto是Java中的保留关键字，但是现在没有在Java中使用。</li>
<li>问题：启动一个线程是用run()还是start()?<br>
答案：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。</li>
<li>问题：说明一下类变量和实例变量的区别。<br>
答案：类变量是所有对象共有的，所有的实例对象都共用一个类变量，内存中只有一处空间存放类变量的值。如果其中一个对象改变了类变量的值，其他对象得到的就是改变后的结果。当类被加载到内存时，类变量就会分配相应的内存空间。</li>
<li>问题：运行时异常与一般异常有何异同？<br>
答案：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。Java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</li>
<li>问题：说明实例方法和类方法的区别？<br>
答案：方法前面有static关键字修饰的为类方法，否则为实例方法。 实例方法可以调用该类中的其他方法；类方法只能调用其他类方法，不能调用实例方法；当类文件加载到内存时，实例方法不会被分配内存空间，只有在对象创建之后才会分配。而类方法在该类被加载到内存时就分配了相应的内存空间。</li>
<li>问题：什么是哈希表？<br>
答案：哈希表又称散列表，是一种能将关键字映射成存储地址的记录存储技术。要存储数据，先设计一种算法（哈希函数），然后根据数据记录的关键字计算出各记录的哈希码，这个哈希码作为与关键字相关的记录数据的索引。要取出记录，只需要根据哈希函数重新计算，得到哈希码后，便可直接到相应位置去存取。</li>
<li>问题：是否可以从一个static方法内部发出对非static方法的调用？<br>
答案：不可以。如果其中包含对象的method()，不能保证对象初始化。</li>
<li>问题：在Java转义字符中，“<code>\uxxxx</code>”代表什么？<br>
答：<code>\uxxxx</code>是Java中的字符编码方式，其中前缀 <code>\u</code>就表示该字符是unicode字符，<code>xxxx</code>表示1到4位16进制数，用这种转义字符形式可以表示unicode字符集中的任意字符。</li>
<li>问题：switch语句中的表达式可以是什么类型数据？<br>
答案：表达式的值可以是byte、short、int和char类型的数据，但不能是float和double类型的数据。</li>
<li>问题：插入数据时，ArrayList、LinkedList、Vector谁速度较快？<br>
答案：ArrayList、Vector以数组方式存储数据，插入数据时要进行元素移动操作，因而插入数据慢。LinkedList是一种链表结构，在插入数据时只需要修改链表的前后项指向即可，因此插入速度较快。</li>
</ol>
<p>#	java基础内容面试题(五)</p>
<ol>
<li>问题：说出一些常用的类，包，接口，请各举5个。<br>
答案：<br>
常用的类：BufferedReader，BufferedWriter，FileReader，FileWirter和String等。<br>
常用的包：Java.lang ，Java.awt，<a href="http://Java.io" target="_blank" rel="noopener">Java.io</a>，Java.util和Java.sql等。<br>
常用的接口：Remote，List，Map，Document和NodeList等。</li>
<li>问题：多线程的实现方法分别是什么?同步的实现方法分别是什么?<br>
答案：多线程有两种实现方法，分别是继承Thread类与实现Runnable。<br>
接口同步的实现方面有两种，分别是synchronized、wait与notify。</li>
<li>问题：当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少？<br>
答案：当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数有n+2个，即除输入的n个字符后，还存储了回车和换行字符。</li>
<li>问题：如何实现字符串的分割？<br>
答案：第一种方法是采用split()方法，将分割后的内容保存在指定的字符串数组中；第二种方法是采用StringTokenizer，利用StringTokenizer的nextToken()、hasMoreTokens()等方法进行分割。</li>
<li>问题：描述一下JVM加载class文件的原理机制?<br>
答案：JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</li>
<li>问题：在什么情况下，finally语句不会执行？<br>
答案：如果在try内部执行一条System.exit(0)语句终止应用程序的执行，则finally中的语句不会被执行。</li>
<li>问题：说出重写和重载的区别，重写方法是否可以改变返回值的类型?<br>
答案：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写是父类与子类之间多态性的一种表现，重载是一个类中多态性的一种表现。<br>
如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载。重载的方法是可以改变返回值的类型。</li>
<li>问题：throw和throws有什么区别？<br>
答案：throw关键字一般用于方法内部，用于抛出一个异常类对象，一旦异常被抛出后，throw语句后的程序代码将不会被执行。<br>
throws关键字通常出现在方法声明中，用来指定该方法可能抛出的异常。如果可能有多个异常抛出，可以使用逗号将它们分隔开。</li>
<li>问题：字符串的compareTo方法结果是什么？<br>
答案：使用compareTo()方法可以比较字符串与字符串之间的大小关系。如果当前字符串小于指定字符串，则返回一个小于0的数值；否则返回一个大于0的数值；如果两个字符串相等，则返回0。</li>
<li>问题：字符串的连接操作有几种实现方法？<br>
答案：字符串与字符串的连接操作可以通过“+”运算符和concat()方法来实现。另外“+”运算符还可以实现字符串与其他类型数据之间的连接操作，可以与字符串连接的数据类型有：int、long、float、double、boolean、char等。</li>
<li>问题：当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>
答案：是值传递，因为在Java编程语言中只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</li>
<li>问题：Class MyClass等价于 Class MyClass extends Object是否正确？<br>
答案：正确。因为Object类是Java中最高层次的类，是所有类的超类。所有的类，都可以说是由Object继承而来，只是我们不需要显式地指明extends Object。</li>
<li>问题：数组有没有length()方法? String有没有length()方法？<br>
答案：数组没有length()方法，只有length的属性。String有length()方法。</li>
<li>问题：面向对象的特征有哪些方面<br>
答案：</li>
</ol>
<ul>
<li>（1）抽象：抽象就是忽略一个主题中与当前目标无关的方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：一个是过程抽象，另外一个是数据抽象。</li>
<li>（2）继承：继承是一种联结类的层次模型，并且允许类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</li>
<li>（3）封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</li>
<li>（4）多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，同时很好地解决了应用程序函数同名问题。</li>
</ul>
<ol start="15">
<li>问题：Java中实现多态的机制是什么？<br>
答案：方法的重写和重载是Java多态性的不同表现。重写是父类与子类之间多态性的一种表现，重载是一个类中多态性的一种表现。</li>
<li>问题：通过JDBC连接数据库有哪几种方式？<br>
答案：JDBC-ODBC bridge driver方式可以访问一个ODBC数据源，但每台客户端计算机需要安装并配置ODBC驱动程序。<br>
Native-API partly Java driver方式将JDBC调用转换成特定数据库API的调用，该方式要求每台客户端计算机安装特定数据库的驱动程序。<br>
JDBC-Net pure Java driver方式将JDBC调用转换为独立于数据库的中间件厂商的专有数据库访问协议，然后由其负责与数据库的连接活动。<br>
Native-protocol pure Java driver方式将JDBC调用转换为数据库直接使用的标准网络协议（例如HTTP等）。这种方式不需要安装客户端软件，客户端计算机可以直接与数据库服务器进行数据“交流”活动。</li>
<li>问题：List、Map、Set三个接口，存取元素时，各有什么特点？<br>
答案：List以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素，内部排序。Map 保存key-value值，value可多值。</li>
<li>问题：什么是循环嵌套？其特点是什么？<br>
答案：循环的嵌套，是指在一个循环语句的循环体中又包含另一个完整的循环语句。多重循环语句的特点是：外层循环变量相对稳定，内层循环变量逐一变化，即：“多层循环，内（层）外（层）有别，外（层）变一次，内（层）变一遍。”</li>
<li>问题：char型变量中能不能存贮一个中文汉字?为什么?<br>
答案：能够定义成为一个中文的，因为Java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的。</li>
<li>问题：error和exception有什么区别<br>
答案：error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。<br>
exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</li>
<li>问题：如何实现Java序列化？<br>
答案：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，它只是为了标注该对象是可被序列化的，然后需要使用一个输出流来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObject()方法就可以将参数为obj的对象写出，要恢复的话则需要使用输入流。</li>
<li>问题：Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？<br>
答案：字节流和字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在Java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</li>
<li>问题：String s=new String(“a”);共创建了几个String对象？<br>
答案：两个。其中包括一个字符对象和一个字符对象引用对象。</li>
</ol>
<h1>JVM的组成、垃圾回收机制</h1>
<p><a href="http://www.tengleitech.com/archives/1211" target="_blank" rel="noopener">http://www.tengleitech.com/archives/1211</a></p>
<p>#	JAVA多线程面试题<br>
<a href="http://www.tengleitech.com/archives/1214" target="_blank" rel="noopener">http://www.tengleitech.com/archives/1214</a></p>
<p>#	List、Set和Map面试题<br>
<a href="http://www.tengleitech.com/archives/1217" target="_blank" rel="noopener">http://www.tengleitech.com/archives/1217</a></p>
<p>#	Spring 面试题</p>
<ol>
<li>什么是spring?<br>
Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</li>
<li>使用Spring框架的好处是什么?<br>
轻量：Spring 是轻量的，基本的版本大约2MB。<br>
控制反转(IOC)：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>
面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>
容器：Spring 包含并管理应用中对象的生命周期和配置。<br>
MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务(JTA)。<br>
异常处理：Spring 提供方便的API把具体技术相关的异常(比如由JDBC，Hibernate or JDO抛出的)转化为一致的unchecked 异常。</li>
<li>Spring由哪些模块组成?<br>
以下是Spring 框架的基本模块：<br>
Core module<br>
Bean module<br>
Context module<br>
Expression Language module<br>
JDBC module<br>
ORM module<br>
OXM module<br>
Java Messaging Service(JMS) module<br>
Transaction module<br>
Web module<br>
Web-Servlet module<br>
Web-Struts module<br>
Web-Portlet module</li>
<li>核心容器(应用上下文) 模块。<br>
这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</li>
<li>BeanFactory – BeanFactory 实现举例。<br>
Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。最常用的BeanFactory 实现是XmlBeanFactory 类。</li>
<li>XMLBeanFactory<br>
最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</li>
<li>解释AOP模块<br>
AOP模块用于发给我们的Spring应用做面向切面的开发， 很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。</li>
<li>解释JDBC抽象和DAO模块。<br>
通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</li>
<li>解释对象/关系映射集成模块。<br>
Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</li>
<li>解释WEB 模块。<br>
Spring的WEB模块是构建在application context 模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对Jakarta Struts的支持。</li>
<li>Spring配置文件<br>
Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</li>
<li>什么是Spring IOC 容器?<br>
Spring IOC 负责创建对象，管理对象(通过依赖注入(DI)，装配对象，配置对象，并且管理这些对象的整个生命周期。</li>
<li>IOC的优点是什么?<br>
IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</li>
<li>ApplicationContext通常的实现是什么?<br>
FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。<br>
ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。<br>
WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li>
<li>Bean 工厂和 Application contexts 有什么区别?<br>
Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源(比如镜像)，它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</li>
<li>一个Spring的应用看起来象什么?<br>
一个定义了一些功能的接口。<br>
这实现包括属性，它的Setter,getter 方法和函数等。<br>
Spring AOP。<br>
Spring 的XML 配置文件。<br>
使用以上功能的客户端程序。<br>
依赖注入</li>
<li>什么是Spring的依赖注入?<br>
依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器(IOC容器)负责把他们组装起来。</li>
<li>有哪些不同类型的IOC(依赖注入)方式?<br>
构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。<br>
Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li>
<li>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入?<br>
你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</li>
<li>什么是Spring beans?<br>
Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。<br>
Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。</li>
<li>一个 Spring Bean 定义 包含什么?<br>
一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li>
<li>如何给Spring 容器提供配置元数据?<br>
这里有三种重要的方法给Spring 容器提供配置元数据。<br>
XML配置文件。<br>
基于注解的配置。<br>
基于java的配置。</li>
<li>你怎样定义类的作用域?<br>
当定义一个bean在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</li>
<li>解释Spring支持的几种bean的作用域。<br>
Spring框架支持以下五种bean的作用域：<br>
singleton : bean在每个Spring ioc 容器中只有一个实例。<br>
prototype：一个bean的定义可以有多个实例。<br>
request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>
session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>
global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>
缺省的Spring bean 的作用域是Singleton.</li>
<li>Spring框架中的单例bean是线程安全的吗?<br>
不，Spring框架中的单例bean不是线程安全的。</li>
<li>解释Spring框架中bean的生命周期。<br>
Spring容器 从XML 文件中读取bean的定义，并实例化bean。<br>
Spring根据bean的定义填充所有的属性。<br>
如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。<br>
如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。<br>
如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。<br>
如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。<br>
如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。<br>
如果bean实现了 DisposableBean，它将调用destroy()方法。</li>
<li>哪些是重要的bean生命周期方法? 你能重载它们吗?<br>
有两个重要的bean 生命周期方法，第一个是setup,它是在容器加载bean的时候被调用。第二个方法是teardown它是在容器卸载类的时候被调用。<br>
The bean 标签有两个重要的属性(init-method和destroy-method)。用它们你可以自己定制初始化和注销方法。它们也有相应的注解(@PostConstruct和@PreDestroy)。</li>
<li>什么是Spring的内部bean?<br>
当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，可以在 或 元素内使用 元素，内部bean通常是匿名的，它们的Scope一般是prototype。</li>
<li>在 Spring中如何注入一个java集合?<br>
Spring提供以下几种集合的配置元素：<br>
类型用于注入一列值，允许有相同的值。<br>
类型用于注入一组值，不允许有相同的值。<br>
类型用于注入一组键值对，键和值都可以为任意类型。<br>
类型用于注入一组键值对，键和值都只能为String类型。</li>
<li>什么是bean装配?<br>
装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</li>
<li>什么是bean的自动装配?<br>
Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和&lt;:property&gt;配置，能通过Bean工厂自动处理bean之间的协作。</li>
<li>解释不同方式的自动装配 。<br>
有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。<br>
no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。<br>
byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。<br>
byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。<br>
constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。<br>
autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li>
<li>自动装配有哪些局限性 ?<br>
自动装配的局限性是：<br>
重写： 你仍需用 和 &lt;:property&gt;配置来定义依赖，意味着总要重写自动装配。<br>
基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。<br>
模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li>
<li>你可以在Spring中注入一个null 和一个空字符串吗?<br>
可以。</li>
<li>什么是基于Java的Spring注解配置? 给一些注解的例子.<br>
基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。<br>
以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</li>
<li>什么是基于注解的容器配置?<br>
相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。<br>
开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</li>
<li>怎样开启注解装配?<br>
注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置元素。</li>
<li>@Required 注解<br>
这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</li>
<li>@Autowired 注解<br>
@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</li>
<li>@Qualifier 注解<br>
当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。</li>
<li>在Spring框架中如何更有效地使用JDBC?<br>
使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate (例子见这里here)</li>
<li>JdbcTemplate<br>
JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li>
<li>Spring对DAO的支持<br>
Spring对数据访问对象(DAO)的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li>
<li>使用Spring通过什么方式访问Hibernate?<br>
在Spring中有两种方式访问Hibernate：<br>
控制反转 Hibernate Template和 Callback。<br>
继承 HibernateDAOSupport提供一个AOP 拦截器。</li>
<li>Spring支持的ORM<br>
Spring支持以下ORM：<br>
Hibernate<br>
iBatis<br>
JPA (Java Persistence API)<br>
TopLink<br>
JDO (Java Data Objects)<br>
OJB</li>
<li>如何通过HibernateDaoSupport将Spring和Hibernate结合起来?<br>
用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br>
配置the Hibernate SessionFactory。<br>
继承HibernateDaoSupport实现一个DAO。<br>
在AOP支持的事务中装配。</li>
<li>Spring支持的事务管理类型<br>
Spring支持两种类型的事务管理：<br>
编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。<br>
声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</li>
<li>Spring框架的事务管理有哪些优点?<br>
它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。<br>
它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如<br>
它支持声明式事务管理。<br>
它和Spring各种数据访问抽象层很好得集成。</li>
<li>你更倾向用那种事务管理类型?<br>
大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理(这种方式允许你通过代码控制事务)少了一点灵活性。</li>
<li>解释AOP<br>
面向切面的编程，或AOP,是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</li>
<li>Aspect 切面<br>
AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。</li>
<li>在Spring AOP 中，关注点和横切关注的区别是什么?<br>
关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>
横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</li>
<li>连接点<br>
连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</li>
<li>通知<br>
通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。<br>
Spring切面可以应用五种类型的通知：<br>
before：前置通知，在一个方法执行前被调用。<br>
after: 在方法执行之后调用的通知，无论方法执行是否成功。<br>
after-returning: 仅当方法成功完成后执行的通知。<br>
after-throwing: 在方法抛出异常退出时执行的通知。<br>
around: 在方法执行之前和之后调用的通知。</li>
<li>切点<br>
切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</li>
<li>什么是引入?<br>
引入允许我们在已存在的类中增加新的方法和属性。</li>
<li>什么是目标对象?<br>
被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知(advised)对象。</li>
<li>什么是代理?<br>
代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</li>
<li>有几种不同类型的自动代理?<br>
BeanNameAutoProxyCreator<br>
DefaultAdvisorAutoProxyCreator<br>
Metadata autoproxying</li>
<li>什么是织入。什么是织入应用的不同点?<br>
织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。<br>
织入可以在编译时，加载时，或运行时完成。</li>
<li>解释基于XML Schema方式的切面实现。<br>
在这种情况下，切面由常规类以及基于XML的配置实现。</li>
<li>解释基于注解的切面实现<br>
在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</li>
<li>什么是Spring的MVC框架?<br>
Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</li>
<li>DispatcherServlet<br>
Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。<br>
WebApplicationContext<br>
WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</li>
<li>什么是Spring MVC框架的控制器?<br>
控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</li>
<li>@Controller 注解<br>
该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用Servlet API。</li>
<li>@RequestMapping 注解<br>
该注解是用来映射一个URL到一个类或一个特定的方处理法上。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-数据库]]></title>
      <url>/2017/09/22/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h1>参考资料：</h1>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="noopener">数据库索引的实现原理</a></p>
<p><a href="http://blog.csdn.net/weiliangliang111/article/details/51333169" target="_blank" rel="noopener">数据库索引到底是什么，怎么工作的</a></p>
<p><a href="http://blog.csdn.net/hguisu/article/details/7786014" target="_blank" rel="noopener">B+,B-树的应用</a></p>
<p><a href="http://www.cnblogs.com/anding/p/3254674.html" target="_blank" rel="noopener">数据库索引及基本优化</a></p>
<p><a href="http://jingyan.baidu.com/article/da1091fbd166ff027849d687.html" target="_blank" rel="noopener">mySql如何创建索引</a></p>
<p><a href="http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html" target="_blank" rel="noopener">B树、B-树、B+树、B*树</a></p>
<p><a href="http://www.cnblogs.com/AK2012/archive/2013/01/04/2844283.html" target="_blank" rel="noopener">Sql索引一步到位</a></p>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[招聘日程]]></title>
      <url>/2017/09/21/%E6%8B%9B%E8%81%98%E6%97%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/school/calendar#lt50=true&amp;lt500=true&amp;gt500=true&amp;attend=true&amp;month=2017-9" target="_blank" rel="noopener">牛客网校招日程</a></p>
<h1>10月</h1>
<table>
<thead>
<tr>
<th style="text-align:center">一</th>
<th style="text-align:center">二</th>
<th style="text-align:center">三</th>
<th style="text-align:center">四</th>
<th style="text-align:center">五</th>
<th style="text-align:center">六</th>
<th style="text-align:center">日</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1>11月</h1>
<table>
<thead>
<tr>
<th style="text-align:center">一</th>
<th style="text-align:center">二</th>
<th style="text-align:center">三</th>
<th style="text-align:center">四</th>
<th style="text-align:center">五</th>
<th style="text-align:center">六</th>
<th style="text-align:center">日</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 日程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-计算机基础]]></title>
      <url>/2017/09/21/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1>进程和线程关系及区别</h1>
<ol>
<li>
<p>定义：进程是系统进行资源分配和调度的一个独立单位。<br>
线程是进程的一个实体,是CPU调度和分派的基本单位。</p>
</li>
<li>
<p>关系：一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。<br>
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p>
</li>
<li>
<p>区别：</p>
</li>
</ol>
<ul>
<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
</ul>
<ol start="4">
<li>优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-动态规划]]></title>
      <url>/2017/09/20/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h1>动态规划-从新手到专家</h1>
<p><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/" target="_blank" rel="noopener">英文原版</a></p>
<p><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="noopener">中文版</a></p>
<p><a href="http://blog.csdn.net/doc_sgl/article/details/9026405" target="_blank" rel="noopener">其他中文版</a></p>
<h1>动态规划</h1>
<p>参考自:<a href="http://blog.csdn.net/liufeng_king/article/details/8490770" target="_blank" rel="noopener">liufeng_king的专栏</a></p>
<p>动态规划：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。</p>
<p>基本思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p>与分治法区别：动态规划算法与分治法类似，都使用了将问题实例归纳为更小的、相似的子问题，并通过求解子问题产生一个全局最优值的思路，但动态规划不是分治法：关键在于分解出来的各个子问题的性质不同。分治法要求各个子问题是独立的(即不包含公共的子问题)，因此一旦递归地求出各个子问题的解后，便可自下而上地将子问题的解合并成原问题的解。如果各子问题是不独立的，那么分治法就要做许多不必要的工作，重复地解公共的子问题。动态规划与分治法的不同之处在于动态规划允许这些子问题不独立(即各子问题可包含公共的子问题)，它对每个子问题只解一次，并将结果保存起来，避免每次碰到时都要重复计算。</p>
<p>相关术语：</p>
<p>(1)阶段：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不<br>
同，描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</p>
<p>(2)状态：状态表示每个阶段开始面临的自然状况或客观条件，也称为不可控因素。过程的状态通常可以用一个或一组数来描述,称为状态变量。一般状态是离散的,但有时为了方便也将状态取成连续的。</p>
<p>(3)无后效性：状态具有下面的性质,如果给定某一阶段的状态,则在这一阶段以后过程的发展不受这阶段以前各段状态的影响,所有各阶段都确定时,整个过程也就确定了。换句话说,过程的每一次实现可以用一个状态序列表示,在前面的例子中每阶段的状态是该线路的始点,确定了这些点的序列,整个线路也就完全确定。从某一阶段以后的线路开始,当这段的始点给定时,不受以前线路,所通过的点,的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展,这个性质称为无后效性。</p>
<p>(4)决策：一个阶段的状态给定以后,从该状态演变到下一阶段某个状态的一种选择(行动)称为决策。在最优控制中,也称为控制。在许多间题中,决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量,因状态满足无后效性,故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。决策变量的范围称为允许决策集合。</p>
<p>(5)策略：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。</p>
<p>(6)最优性原理: 作为整个过程的最优策略,它满足,相对前面决策所形成的状态而言,余下的子策略必然构成―最优子策略。</p>
<p>问题特征：</p>
<p>(1)最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p>
<p>(2)重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。</p>
<p>算法步骤：</p>
<p>(1)分析最优值的结构，刻画其结构特征；</p>
<p>(2)递归地定义最优值；</p>
<p>(3)按自底向上或自顶向下记忆化的方式计算最优</p>
<h1>一维DP</h1>
<h2 id="斐波那契数列">斐波那契数列</h2>
<blockquote>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）</p>
</blockquote>
<p>按照定义，可以很容易的写出其递归解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciPolynomial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner reader =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(reader.hasNextInt())&#123;</span><br><span class="line">			<span class="keyword">int</span> n=reader.nextInt();</span><br><span class="line">			System.out.println(fib(n));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归解</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在n=5时，fib(5)的计算过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fib(5)</span><br><span class="line">fib(4) + fib(3)</span><br><span class="line">(fib(3) + fib(2)) + (fib(2) + fib(1))</span><br><span class="line">((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</span><br><span class="line">(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</span><br></pre></td></tr></table></figure>
<p>由上面可以看出，这种算法对于相似的子问题进行了重复的计算，因此不是一种高效的算法。实际上，该算法的运算时间是指数级增长的。 改进的方法是，我们可以通过保存已经算出的子问题的解来避免重复计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 裴波那切数列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YR</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciPolynomial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner reader =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(reader.hasNextInt())&#123;</span><br><span class="line">			<span class="keyword">int</span> n=reader.nextInt();</span><br><span class="line">			System.out.println(fibo(n));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 非递归解</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">1</span>||n==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			f[i]=f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f[n];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最少硬币问题">最少硬币问题</h2>
<blockquote>
<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？</p>
</blockquote>
<p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p>
<p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p>
<p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的&quot;状态&quot;， 这个状态是怎么找出来的呢？你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<p>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</p>
<p>有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> coinNum=<span class="number">3</span>; <span class="comment">//硬币种类</span></span><br><span class="line">		<span class="keyword">int</span>[] coins=<span class="keyword">new</span> <span class="keyword">int</span>[coinNum];<span class="comment">//各个硬币的面值</span></span><br><span class="line">		coins[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		coins[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">		coins[<span class="number">2</span>]=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">int</span> n=<span class="number">11</span>;<span class="comment">//需要的总数</span></span><br><span class="line">		<span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">		System.out.println(getMinCoinNum(coins, n,dp));</span><br><span class="line">		System.out.println(getMinCoinStr(dp, n).trim());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用coins凑够n所需的最少硬币数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> coins 硬币面额</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dp 动态规划矩阵。d[n][0]为凑够n所需的最少硬币数，d[n][1]为所用的最后一个硬币</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinCoinNum</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> n,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		String coinStr=<span class="string">""</span>;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> coinCount=i;</span><br><span class="line">			<span class="keyword">int</span> curCoin=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i-coin&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">int</span> count=dp[i-coin][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(count&lt;coinCount)&#123;</span><br><span class="line">						coinCount=count;</span><br><span class="line">						dp[i][<span class="number">1</span>]=coin;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][<span class="number">0</span>]=coinCount;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回所用硬币序列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dp</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMinCoinStr</span><span class="params">(<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		String line=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">int</span> curCoin=dp[n][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span>(curCoin&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			line=curCoin+<span class="string">" "</span>+line;</span><br><span class="line">			n=n-curCoin;</span><br><span class="line">			curCoin=dp[n][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> line;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长非降子序列-longest-increasing-subsequence-lis">最长非降子序列（longest increasing subsequence，LIS）</h2>
<p>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p>
<p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p>
<p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p>
<p>为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是：</p>
<p>5，3，4，8，6，7</p>
<p>根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）<br>
前1个数的LIS长度d(1)=1(序列：5)<br>
前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)<br>
前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)<br>
前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)</p>
<p>OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：</p>
<p>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]</p>
<p>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingSubsequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String seqStr=<span class="string">"5 3 4 8 6 7"</span>;</span><br><span class="line">		String[] nums=seqStr.split(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">int</span> n=nums.length;</span><br><span class="line">		<span class="keyword">int</span>[] seq=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			seq[i]=Integer.parseInt(nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(lis(seq, n, dp));</span><br><span class="line">		System.out.println(lisSeq(seq, dp));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回最长非降子序列长度</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> seq 序列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n 序列长度</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dp 矩阵,dp[i][0]表示以seq[i]结尾的最长非降子序列长度，dp[i][1]表示该子序列上一个字符在seq中的索引。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] seq,<span class="keyword">int</span> n,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> lisLength=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(seq[j]&lt;seq[i])&#123;</span><br><span class="line">					<span class="keyword">int</span> curLength=dp[j][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(curLength&gt;=lisLength)&#123;</span><br><span class="line">						lisLength=curLength;</span><br><span class="line">						dp[i][<span class="number">1</span>]=j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][<span class="number">0</span>]=lisLength;</span><br><span class="line">			<span class="keyword">if</span>(lisLength==<span class="number">1</span>)&#123;</span><br><span class="line">				dp[i][<span class="number">1</span>]=i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(lisLength&gt;=max)&#123;</span><br><span class="line">				max=lisLength;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取最长非降子序列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dp</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lisSeq</span><span class="params">(<span class="keyword">int</span>[] seq,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">		String line=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i][<span class="number">0</span>]&gt;=max)&#123;</span><br><span class="line">				index=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> preIndex=dp[index][<span class="number">1</span>];</span><br><span class="line">		line=seq[index]+<span class="string">" "</span>+line;</span><br><span class="line">		<span class="keyword">while</span>(preIndex!=index)&#123;</span><br><span class="line">			index=preIndex;</span><br><span class="line">			preIndex=dp[index][<span class="number">1</span>];</span><br><span class="line">			line=seq[index]+<span class="string">" "</span>+line;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> line;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>二维DP</h1>
<p>接下来，让我们来看看如何解决二维的DP问题。</p>
<p>平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。</p>
<p>解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。</p>
<p>首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解)</p>
<p>经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下：</p>
<p>S[i][j]=A[i][j] + max(S[i-1][j], if i&gt;0 ; S[i][j-1], if j&gt;0)</p>
<p>其中i代表行，j代表列，下标均从0开始；A[i][j]代表格子(i, j)处的苹果数量。</p>
<p>S[i][j]有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算S[i][j]时，S[i-1][j]和S[i][j-1]都已经计算出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostAppleCollected</span><span class="params">(<span class="keyword">int</span>** A, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>** S = <span class="keyword">new</span> <span class="keyword">int</span>*[n];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; n; ++i)  </span><br><span class="line">        S[i] = <span class="keyword">new</span> <span class="keyword">int</span>[m];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> increment = A[i][j];  </span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)  </span><br><span class="line">                up = S[i<span class="number">-1</span>][j];  </span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)  </span><br><span class="line">                left = S[i][j<span class="number">-1</span>];  </span><br><span class="line">            <span class="keyword">int</span> neighbor = left &gt;= up ? left : up;  </span><br><span class="line"></span><br><span class="line">            S[i][j] = neighbor + increment;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> result = S[n<span class="number">-1</span>][m<span class="number">-1</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  </span><br><span class="line">        <span class="keyword">delete</span> []S[i];  </span><br><span class="line">    <span class="keyword">delete</span> []S;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子串-longest-commonsubsequence-lcs">最长公共子串(Longest CommonSubsequence, LCS)</h2>
<p>原文参考：<a href="http://www.cnblogs.com/javawebsoa/p/3220049.html" target="_blank" rel="noopener">javawebsoa的博客</a>和<a href="http://www.cnblogs.com/7explore-share/p/5927292.html" target="_blank" rel="noopener">aritficerpi的Blog</a></p>
<blockquote>
<p>题目：如果字符串一的所有字符按其在字符串中的顺序出现在另外一个字符串二中，则字符串一称之为字符串二的子串。<br>
注意，并不要求子串（字符串一）的字符必须连续出现在字符串二中。</p>
</blockquote>
<p>请编写一个函数，输入两个字符串，求它们的最长公共子串，并打印出最长公共子串。<br>
例如：输入两个字符串BDCABA和ABCBDAB，字符串BCBA和BDAB都是是它们的最长公共子串，<br>
则输出它们的长度4，并打印任意一个子串。</p>
<p>求最长公共子串（Longest CommonSubsequence, LCS）是一道非常经典的动态规划题。</p>
<p>先介绍LCS问题的<strong>性质</strong>：记$X_m={x_0, x_1,…,x_{m-1}}$ 和$Y_n={y_0,y_1,…,y_{n-1}}$ 为两个字符串，并设$Z_k={z_0,z_1,…,z_{k-1}}$ 是$X$ 和$Y$ 的任意一个LCS，则可得出3条性质：</p>
<ol>
<li>如果$x_{m-1}=y_{n-1}$ ，那么$z_{k-1}=x_{m-1}=y_{n-1}$ ，并且$Z_{k-1}$ 是$X_{m-1}$ 和$Y_{n-1}$ 的一个LCS；</li>
<li>如果xm-1≠yn-1，那么当zk-1≠xm-1时，Z是Xm-1和Y的LCS；</li>
<li>如果xm-1≠yn-1，那么当zk-1≠yn-1时，Z是X和Yn-1的LCS；</li>
</ol>
<p>下面简单证明一下由上述相应条件得出的这些性质：</p>
<ol>
<li>如果zk-1≠xm-1，那么我们可以把xm-1（yn-1）加到Z中得到Z’，这样就得到X和Y的一个长度为k+1的公共子串Z’。这就与长度为k的Z是X和Y的LCS相矛盾了。因此一定有zk-1=xm-1=yn-1。既然zk-1=xm-1=yn-1，那如果我们删除zk-1（xm-1、yn-1）得到的Zk-1，Xm-1和Yn-1，显然Zk-1是Xm-1和Yn-1的一个公共子串，现在我们证明Zk-1是Xm-1和Yn-1的LCS。用反证法不难证明。假设有Xm-1和Yn-1有一个长度超过k-1的公共子串W，那么我们把加到W中得到W’，那W’就是X和Y的公共子串，并且长度超过k，这就和已知条件相矛盾了。</li>
<li>还是用反证法证明。假设Z不是Xm-1和Y的LCS，则存在一个长度超过k的W是Xm-1和Y的LCS，那W肯定也X和Y的公共子串，而已知条件中X和Y的公共子串的最大长度为k。矛盾。</li>
<li>证明同2。</li>
</ol>
<p>根据上面的性质，我们可以得出如下的思路：</p>
<ol>
<li>如果xm-1=yn-1，那么只需求得Xm-1和Yn-1的LCS，并在其后添加xm-1（yn-1）即可（上述性质1）；</li>
<li>如果xm-1≠yn-1，我们分别求得Xm-1和Y的LCS和Yn-1和X的LCS，并且这两个LCS中较长的一个为X和Y的LCS（上述性质2、3）。</li>
</ol>
<p>将输入字符串1看作行， 输入字符串2看作列，构成二位数组，然后将对角线匹配字符的值标记为1，计算满足条件的匹配字符个数即可。则其状态转移方程为：</p>
<p>$$<br>
C[i,j]=\begin{cases} 0 &amp;若i=0或者j=0 \ C[i-1,j-1]+1 &amp;若i,j&gt;0,x_i=y_i \ max{C[i,j-1],C[i-1,j]} &amp;若i,j&gt;0,x_i\not=y_i<br>
\end{cases}<br>
$$</p>
<p>如下图所示：<br>
<img src="/2017/09/20/面试笔试题-动态规划/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E7%9F%A9%E9%98%B5.JPG" alt="最长子串示例"></p>
<p>java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find longest common sequence from two input string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> length of longest common sequence</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LCS</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s2.length()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the elements without top left element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;s2.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(<span class="number">0</span>) == s2.charAt(j)) &#123;</span><br><span class="line">                c[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i][j - <span class="number">1</span>] &gt; c[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c[s1.length() - <span class="number">1</span>][s2.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find longest substring from two input string</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> length of longest substring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LSS</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s2.length()];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize the elements without top left element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;s2.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(<span class="number">0</span>) == s2.charAt(j)) &#123;</span><br><span class="line">                c[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c[i][j] &gt; max) &#123;</span><br><span class="line">                        max = c[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>c++实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划_最大子串.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">#include "stdafx.h"</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> decreaseDir&#123;kInit=<span class="number">0</span>,kLeft,kUp,kLeftUp&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCS_Print</span><span class="params">(<span class="keyword">int</span>** LCS_dirction,string pStr1,string pStr2,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(string pStr1,string pStr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//if(!pStr1||!pStr2)return 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> length1=pStr1.length();</span><br><span class="line">	<span class="keyword">int</span> length2=pStr2.length();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!length1||!length2)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span>** LCS_length;</span><br><span class="line">    LCS_length=(<span class="keyword">int</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length1]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length1;i++)</span><br><span class="line">		LCS_length[i]=(<span class="keyword">int</span>*)<span class="keyword">new</span> <span class="keyword">int</span>[length2];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length1;++i)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;length2;++j)</span><br><span class="line">			LCS_length[i][j]=<span class="number">0</span>;              <span class="comment">//初始化length matrix</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>** LCS_dirction;</span><br><span class="line">	LCS_dirction=(<span class="keyword">int</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length1]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length1;++i)</span><br><span class="line">		LCS_dirction[i]=(<span class="keyword">int</span>*)<span class="keyword">new</span> <span class="keyword">int</span>[length2];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length1;++i)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;length2;++j)</span><br><span class="line">			LCS_dirction[i][j]=kInit;          <span class="comment">//初始化dirction matrix</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length1;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;length2;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(pStr1[i]==pStr2[j])</span><br><span class="line">				&#123;</span><br><span class="line">					LCS_length[i][j]=<span class="number">1</span>;</span><br><span class="line">					LCS_dirction[i][j]=kLeftUp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> LCS_length[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(pStr1[i]==pStr2[j])</span><br><span class="line">			&#123;</span><br><span class="line">				LCS_length[i][j]=LCS_length[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">				LCS_dirction[i][j]=kLeftUp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(LCS_length[i-<span class="number">1</span>][j]&gt;LCS_length[i][j-<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				LCS_length[i][j]=LCS_length[i-<span class="number">1</span>][j];</span><br><span class="line">				LCS_dirction[i][j]=kUp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				LCS_length[i][j]=LCS_length[i][j-<span class="number">1</span>];</span><br><span class="line">				LCS_dirction[i][j]=kLeft;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LCS_Print(LCS_dirction,pStr1,pStr2,length1-<span class="number">1</span>,length2-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> LCS_length[length1-<span class="number">1</span>][length2-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCS_Print</span><span class="params">(<span class="keyword">int</span>** LCS_dirction,string pStr1,string pStr2,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//if(pStr1==NULL||pStr2==NULL)return;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> length1=pStr1.length();</span><br><span class="line">	<span class="keyword">int</span> length2=pStr2.length();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(length1==<span class="number">0</span>||length2==<span class="number">0</span>||!(row&lt;length1&amp;&amp;col&lt;length2))<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(LCS_dirction[row][col]==kLeftUp)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span>(row&gt;<span class="number">0</span>&amp;&amp;col&gt;<span class="number">0</span>)</span><br><span class="line">		    LCS_Print(LCS_dirction,pStr1,pStr2,row-<span class="number">1</span>,col-<span class="number">1</span>);</span><br><span class="line">	    printf(<span class="string">"%c"</span>,pStr1[row]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(LCS_dirction[row][col]==kLeft)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(col&gt;<span class="number">0</span>)</span><br><span class="line">			LCS_Print(LCS_dirction,pStr1,pStr2,row,col-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(LCS_dirction[row][col]==kUp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(row&gt;<span class="number">0</span>)</span><br><span class="line">			LCS_Print(LCS_dirction,pStr1,pStr2,row-<span class="number">1</span>,col);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_tmain</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1=<span class="string">"BDCABA"</span>;</span><br><span class="line">	<span class="comment">//char str1[]=&#123;'B','D','C','A','B','A'&#125;;</span></span><br><span class="line">	string str2=<span class="string">"ABCBDAB"</span>;</span><br><span class="line">	<span class="comment">//char str2[]=&#123;'A','B','C','B','D','A','B'&#125;;</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">"存在的一个最大子串为："</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">int</span> Length=LCS(str1,str2);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;<span class="string">"最大子串的长度为："</span>&lt;&lt;Length&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不等式数列">不等式数列</h2>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/621e433919214a9ba46087dd50f09879" target="_blank" rel="noopener">牛客网</a></p>
<p>度度熊最近对全排列特别感兴趣,对于1到n的一个排列,度度熊发现可以在中间根据大小关系插入合适的大于和小于符号(即 ‘&gt;’ 和 ‘&lt;’ )使其成为一个合法的不等式数列。但是现在度度熊手中只有k个小于符号即(’&lt;’’)和n-k-1个大于符号(即’&gt;’),度度熊想知道对于1至n任意的排列中有多少个排列可以使用这些符号使其为合法的不等式数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一行,包含两个整数n和k(k &lt; n ≤ 1000)</span><br><span class="line">输出描述:</span><br><span class="line">输出满足条件的排列数,答案对2017取模。</span><br><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">5 2</span><br><span class="line">输出</span><br><span class="line">66</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong><br>
dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1)) % 2017;<br>
dp[i][j]表示有i个数字及j个小于号所能组成的数量(大于号数量当然是i - j - 1次，后面需要使用)<br>
而加入第i + 1个数字时，分以下四种情况：<br>
1.如果将i+1插入当前序列的开头，即有了1&lt;2，加入后成为3&gt;1&lt;2，会发现等于同时加入了一个大于号！(此时可以无视1与2之间的关系，因为i+1&gt;i)<br>
2.如果将i+1插入当前序列末尾,即1&lt;2变成了 1&lt;2&lt;3，会发现等于同时加入了一个小于号！ (此时可以无视1与2之间的关系，因为i+1&gt;i)<br>
3.如果将i+1加入一个小于号之间，即已经有 1&lt;2了，向中间加入3,会发现变成了1&lt;3&gt;2，等于同时加入了一个大于号！<br>
4.如果将i+1加入一个大于号中间，即有了2&gt;1，变成了2&lt;3&gt;1，等于同时加入了一个小于号！<br>
综上所述，dp[i][j]等于以上四种情况之和：<br>
dp[i - 1][j] 将i加在开头等于加入一个大于号，即要求i-1个数时已经有了j个小于号<br>
dp[i - 1][j - 1] 将i加在末尾等于加入一个小于号，即要求i-1个数时已经有了j-1个小于号<br>
dp[i - 1][j] * j 将i加在任意一个小于号之间，等于加入了一个大于号；即要求i-1个数时已经有了j个小于号，每个小于号都可以进行这样的一次插入<br>
dp[i - 1][j - 1] * (i- j - 1) 将i加载任意一个大于号之间，等于加入了一个小于号；即要求i-1个数时有了j-1个小于号，而此时共有<br>
(i - 1) - (j - 1)- 1个大于号，每个大于号都要进行一次这样的操作合并同类项即为<br>
dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1))<br>
最后要记得取模</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k &amp;&amp; j&lt;i;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i-<span class="number">1</span>)dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;j-<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = (dp[i-<span class="number">1</span>][j-<span class="number">1</span>]*(i-j) + dp[i-<span class="number">1</span>][j]*(j+<span class="number">1</span>))%<span class="number">2017</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(dp[n][k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>真题练习</h1>
<h2 id="数字和为sum的方法数">数字和为SUM的方法数</h2>
<p><a href="https://www.nowcoder.com/questionTerminal/7f24eb7266ce4b0792ce8721d6259800" target="_blank" rel="noopener">牛客网连接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个有n个正整数的数组A和一个整数sum,求选择数组A中部分数字和为sum的方案数。</span><br><span class="line">当两种选取方案有一个数字的下标不一样,我们就认为是不同的组成方案。</span><br><span class="line"></span><br><span class="line">输入为两行:</span><br><span class="line">第一行为两个正整数n(1 ≤ n ≤ 1000)，sum(1 ≤ sum ≤ 1000)</span><br><span class="line">第二行为n个正整数A[i](32位整数)，以空格隔开。</span><br><span class="line"></span><br><span class="line">输出所求的方案数</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">5 15 5 5 10 2 3</span><br><span class="line">输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>解法1</strong>：使用递归。运算超时，通过率50%</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner reader=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(reader.hasNextInt())&#123;</span><br><span class="line">			<span class="keyword">int</span> n=reader.nextInt();</span><br><span class="line">			<span class="keyword">int</span> sum=reader.nextInt();</span><br><span class="line">			<span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				a[i]=reader.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(sumNum(a, <span class="number">0</span>, sum));</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumNum</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;a.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum-a[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				num+=sumNum(a, i+<span class="number">1</span>, sum-a[i]);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum-a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法2</strong>：使用循环，用二维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1002</span>][<span class="number">1002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">1002</span>];</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;sum) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, A + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sum; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= A[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - A[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n][sum]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法3</strong>：使用循环，用一维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 给定一个有n个正整数的数组A和一个整数sum,求选择数组A中部分数字和为sum的方案数。</span></span><br><span class="line"><span class="comment">当两种选取方案有一个数字的下标不一样,我们就认为是不同的组成方案。</span></span><br><span class="line"><span class="comment">   解：此题使用递归的遍历方法也可以解决，但是会超时</span></span><br><span class="line"><span class="comment">   dp解决：</span></span><br><span class="line"><span class="comment">   以每个物品作为横轴，以背包容量作为纵轴</span></span><br><span class="line"><span class="comment">       0 1 2 3 4 5 6..........</span></span><br><span class="line"><span class="comment">     0 1 0 0 0 0 0 0..........</span></span><br><span class="line"><span class="comment">     5 1 0 0 0 0 1 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      其中1表示前n件物品放入容量为M的背包有1种方法，（5，0）表示重量为5的物品放入容量为0的背包的背包有1中方法，即不放入。0表示恰好放满背包的方法为0</span></span><br><span class="line"><span class="comment">      当M&gt;weight[i]时，dp[M]=dp[M]+dp[M-weight[i]];意义是：放入物品i和不放入物品i的方法总和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">bag</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> n,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> dp[]=<span class="keyword">new</span> <span class="keyword">long</span>[sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=sum;j&gt;=weight[i];j--)&#123;</span><br><span class="line">               dp[j]=dp[j-weight[i]]+dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner s=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=s.nextInt();</span><br><span class="line">        <span class="keyword">int</span> sum=s.nextInt();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> arr[]=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i]=s.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bag(arr,n,sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试题-网络]]></title>
      <url>/2017/09/20/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h1>1.TCP协议中三次握手与四次挥手</h1>
<h2 id="三次握手">三次握手</h2>
<p><img src="/2017/09/20/面试笔试题-网络/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="三次握手"></p>
<p>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p>
<h2 id="四次挥手">四次挥手</h2>
<p><img src="/2017/09/20/面试笔试题-网络/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="四次挥手"></p>
<p><strong>注意：中断连接端可以是Client端，也可以是Server端。</strong></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了。</p>
<p><strong>问题1：</strong> 为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br>
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手手。</p>
<p><strong>问题2：</strong> 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br>
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试笔试资料汇总]]></title>
      <url>/2017/09/20/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h1>笔试面试经验</h1>
<p><a href="http://blog.csdn.net/cloud_xiaobai/article/list/1" target="_blank" rel="noopener">cloud_xiaobai的博客</a>,机器学习方面面试常见问题总结。</p>
<p><a href="https://www.zhihu.com/question/23259302" target="_blank" rel="noopener">如何准备机器学习工程师的面试</a>,知乎讨论。</p>
<p><a href="http://www.cnblogs.com/GarfieldEr007/p/5342797.html" target="_blank" rel="noopener">计算机IT求职学习List</a>,算法相关、机器学习、在线编程</p>
<h1>在线刷题网站</h1>
<p><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></p>
]]></content>
      
        <categories>
            
            <category> 面试笔试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 资料 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[规划的本质是将未来带到现在]]></title>
      <url>/2017/09/15/%E8%A7%84%E5%88%92%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%B0%86%E6%9C%AA%E6%9D%A5%E5%B8%A6%E5%88%B0%E7%8E%B0%E5%9C%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>《如何掌控自己的时间》<br>
阿兰·拉金（ALan Lakein）著  刘翔亚 译<br>
金城出版社*</p>
</blockquote>
<p><strong>除了处理A-1任务之外，其他都是在浪费时间！</strong>。列出计划，找到A级目标，划分出A-1级任务，立刻执行才是正道。</p>
<h2 id="如何列出目标和任务">如何列出目标和任务</h2>
<p><strong>目标</strong>：长期目标<br>
<strong>任务</strong>：为实现目标所需要完成的任务<br>
<strong>活动</strong>：为完成任务所需采取的具体行动<br>
可以十年、三年、六个月为期限列出目标，划分A、B、C级，将A级目标划分为A-1，A-2，A-3任务。选择A-1任务，制定具体活动。期间随时删掉不重要、不想做的目标、任务。专注于A-1。</p>
<h2 id="日程与习惯">日程与习惯</h2>
<ol>
<li>规划日程，并注意观察反馈，找出时间都浪费在了什么地方，针对性的改正。</li>
<li><strong>养成在固定时间做固定事情的习惯</strong>，这样可以避免将精力耗费在思考和做决定上了。</li>
<li><strong>黄金时间</strong>要严格安排给重要的事情。</li>
<li>尽量缩短<strong>过渡时间</strong>，或利用好过渡时间。</li>
</ol>
<h2 id="避免拖延的方法">避免拖延的方法</h2>
<ol>
<li>不要沉浸在B、C级任务带来的<strong>廉价的成就感</strong>里，只有A级任务是有意义的。80%的效益由20%的工作产生，很多事情是可做可不做的！</li>
<li>开始A-1任务之前需要做信息和工具的准备，但是<strong>不要让这些准备工作转移了注意力</strong>，一切活动都是为高效完成A-1任务服务的。</li>
<li><strong>哪怕只有10分钟时间，也要开始一项A-1任务</strong></li>
<li>每当感到自己走神的时候，感觉自己没有好好利用时间的时候，感觉太忙的时候，停下来静一静，思考一下，<strong>我现在最应该做什么</strong>。分析自己做出每一个决定的原因，将注意力转回到A-1任务上！</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 个人提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 时间管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[番茄工作法]]></title>
      <url>/2017/09/15/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1>番茄工作法</h1>
<h2 id="调节大脑状态-提高注意力">调节大脑状态，提高注意力</h2>
<blockquote>
<p>通过执行一套固定的动作或准备程序可以让大脑自我调整进入预定的工作状态</p>
</blockquote>
<ul>
<li>养成固定习惯，可以让大脑更容易进入状态。<br>
例如：晚上固定“刷牙-睡觉”的节奏，中间不加任何活动，这样刷牙时大脑就能够调节到准备睡觉的状态。</li>
<li>培养固定的习惯还可以压缩或者利用过渡时间。<br>
例如：早上起床固定“洗漱-&gt;背单词”的节奏，这样就能够在洗漱的时候让大脑调节到准备工作的状态。</li>
<li>固定的动作能够培养良好的“节奏感”<br>
例如：扭番茄钟的动作可以给自己一个&quot;开始工作&quot;的明确的心理暗示，帮助调节状态。</li>
</ul>
<h2 id="活动规划">活动规划</h2>
<h3 id="决策-执行-休息-反馈的循环">决策-&gt;执行-&gt;休息-&gt;反馈的循环</h3>
<ul>
<li>工作内容和方法需要不断评估和调整，但是过于频繁或盲目的调整、规划会浪费掉大量的时间。并且只做计划迟迟不动手也是变相的拖延。立即动手比空想有效的多，何况只有在实践中才能发现问题和调整策略。最好的方法就是固定“规划-&gt;活动”节奏，培养<strong>立即动手</strong>的习惯。</li>
<li>工作记忆容量有限，来回切换当前任务会导致注意力降低。开始活动就要全神贯注，完成一个番茄再做调整也不迟。</li>
<li>适当的休息有助于更好的思考和集中注意力</li>
</ul>
<h3 id="交替和持续-从两个不同角度考虑时间">交替和持续——从两个不同角度考虑时间。</h3>
<blockquote>
<p>※  时间是持续的：“我已经逛街两小时了，而且还没逛完”或“哦，我得在10分钟内赶上公车”或“你需要多长时间完成这项任务？”这里的时间表示两点的距离——起点到终点。<br>
※  时间是交替的：鸡1生蛋2、蛋2生鸡3、鸡3生蛋4，依次类推。这些事件互不重叠，我们可能不知道具体时间，但我们知道其发生顺序。<br>
从时间持续的角度来看，对未来进行思考、计算和划分，无异于盲人摸象一般，至少在以全新的方法面对全新的任务时，会是如此。对于我和大多数人来说，正是这种不可预测性导致了焦虑。而焦虑无疑会导致生产力下降，甚至可能把事情搞砸。<strong>如果我们能将工作视为一连串的事件各个击破，生产力将得以提高。</strong></p>
</blockquote>
<p>预估完成任务的时间较难，但如果长期进行跟踪反馈的话，可以大致预估完成任务所需要的番茄数，从而能够更合理地进行活动规划。<br>
用“番茄”代替时间来进行活动规划似乎更便于调整和记录反馈</p>
<h2 id="战胜拖延">战胜拖延</h2>
<ol>
<li>**“完成一个番茄”本身是一个即时奖励，**这样可以将长期目标的遥遥无期的奖励分解为一个一个小的及时奖励，产生完成任务的动力。最终目标是培养成为习惯，减少对“激励”的依赖。</li>
<li><strong>拖延=焦虑</strong>。拖延的时候想一想为何产生了焦虑。</li>
</ol>
<h3 id="导致焦虑的原因："><strong>导致焦虑的原因：</strong></h3>
<ol>
<li>需做的事不是想做的事</li>
<li>想要有完美的表现，导致压力过大</li>
<li>害怕犯错误或受批评</li>
<li>信心不足，怕做不完</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 个人提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 时间管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Keras安装]]></title>
      <url>/2017/08/04/Keras%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h1>Keras安装与配置</h1>
<h2 id="keras安装">Keras安装</h2>
<p>安装参考<a href="http://keras-cn.readthedocs.io/en/latest/for_beginners/keras_windows/" target="_blank" rel="noopener">Keras中文文档</a></p>
<h2 id="配置过程中的问题">配置过程中的问题</h2>
<ol>
<li>执行<code>import keras</code>时报错<code>attributeerror module &quot;pandas&quot; has no attribute &quot;computation&quot;</code><br>
<strong>解决</strong>：可能是在pandas-0.20.2里没有这个属性，所以需要把pandas的版本换为老版本的（如pandas-0.19.2为例）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda remove pandas</span><br><span class="line">conda install pandas=0.19.2</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装<code>tensorflow</code>时出现<code>“Cannot remove entries from nonexistent file c:\program files\anaconda3\lib\site-packages\easy-install.pth”</code><br>
原因：因为setuptools版本太低，tensorflow要求29.0.1，当前版本为27.2.0,在更新setuptools版本的时候又找不到easy-install.pth，导致更新失败<br>
解决：<code>pip install --upgrade --ignore-installed setuptools</code></li>
</ol>
<h1>Anaconda常用命令</h1>
<h3 id="python环境管理">python环境管理</h3>
<p><code>conda create --name python2 python=2.7</code> ：创建新环境并指明版本。</p>
<p><code>conda remove --name python2 --all</code>：删除一个已有环境</p>
<p><code>avtivate python2</code>：激活环境</p>
<p><code>deactivate python3</code>：返回默认环境</p>
<p><code>conda info --envs</code>：列出所有环境</p>
<p><code>conda info --envis</code>：显示当前环境</p>
<h3 id="包管理">包管理</h3>
<p><code>conda install numpy=1.9.3</code>：安装指定版本包</p>
<p><code>conda remove</code></p>
<p><code>conda update</code></p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Keras </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo配置与常用命令]]></title>
      <url>/2017/08/02/hexo%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1>hexo+github建立个人博客</h1>
<p>建站参考<a href="http://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">muyunyun</a>的一篇博客。步骤很详细。</p>
<h1>hexo常用命令</h1>
<h2 id="hexo部署">hexo部署</h2>
<ul>
<li><code>hexo clean</code> : 清除。需要重新部署时（如修改主题之后），需要运行此命令</li>
<li><code>hexo g</code> : 生成</li>
<li><code>hexo d</code> : 发布</li>
<li><code>hexo d -g</code> : 上两个命令的合成</li>
</ul>
<h2 id="写文章">写文章</h2>
<p>发布文章有两种方式</p>
<ol>
<li><code>hexo new &quot;title&quot;</code> : 新建一篇博客</li>
<li><code>hexo new draft &quot;title&quot;</code> : 新建草稿 <br> <code>hexo publish &quot;title&quot;</code> : 将草稿发布</li>
</ol>
<h3 id="文章内容">文章内容</h3>
<pre><code>title: name #文章标题
date: 2015-12-25 19:23:00 #写作时间
description: #文章描述
categories: #文章分类
- c1
tags: #文章标签
- tag1
- tag2
toc: true #生成目录
author:
comments:
original:
permalink: #指定链接    
</code></pre>
<h1>hexo功能扩展</h1>
<h2 id="支持图片">支持图片</h2>
<p>方法参考<a href="http://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="noopener">阿祥JOKER的博客</a></p>
<p>首先设置<code>_config.yml</code>中<code>post_asset_folder:true</code>。<br>
在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把与该文章相关的所有资源都放到那个文件夹。</p>
<p>在blog目录下执行：<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>
<p>文件中使用<code>![logo](本地图片测试/logo.jpg)</code>就可以插入本地图片了。</p>
<h2 id="支持tex数学公式">支持Tex数学公式</h2>
<p>方法参考<a href="http://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">ShallowLearner的博客</a></p>
<ol>
<li>更换Hexo的markdown渲染引擎</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>接下来到博客根目录下，找到<code>node_modules\kramed\lib\rules\inline.js</code>，把第11行的<code>escape</code>变量和20行的<code>em</code>变量的值做相应的修改：</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  <span class="built_in">escape</span>: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  <span class="built_in">escape</span>: /^\\([`*\[\]()#$+\-.!_&gt;])/</span><br><span class="line"></span><br><span class="line">//  <span class="keyword">em</span>: /^\b_((?:__|[\s\S])+?)_\<span class="keyword">b</span>|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">  <span class="keyword">em</span>: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在文章的Front-matter里打开mathjax开关，如下：</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: <span class="built_in">index</span>.html</span><br><span class="line">date: <span class="number">2016</span>-<span class="number">12</span>-<span class="number">28</span> <span class="number">21</span>:<span class="number">01</span>:<span class="number">30</span></span><br><span class="line"><span class="keyword">tag</span><span class="variable">s:</span></span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="站内搜索">站内搜索</h2>
<p><code>npm install hexo-generator-search --save</code></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
