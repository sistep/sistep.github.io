<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>面试笔试题-排序算法 | Mr.骑鱼驴</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面试笔试题-排序算法</h1><a id="logo" href="/.">Mr.骑鱼驴</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">面试笔试题-排序算法</h1><div class="post-meta">Sep 28, 2017<span> | </span><span class="category"><a href="/categories/面试笔试/">面试笔试</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序-稳定"><span class="toc-text">插入排序 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序-缩小增量排序-不稳定"><span class="toc-text">希尔排序(缩小增量排序) 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序-不稳定"><span class="toc-text">选择排序 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序-稳定"><span class="toc-text">冒泡排序 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序-不稳定"><span class="toc-text">快速排序 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序-稳定"><span class="toc-text">归并排序 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序-稳定"><span class="toc-text">基数排序 稳定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-text">排序算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序"><span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单插入排序"><span class="toc-text">简单插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二分插入排序"><span class="toc-text">二分插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序"><span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单选择排序"><span class="toc-text">简单选择排序</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1>参考资料</h1>
<p><a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a><br>
<a href="http://www.cnblogs.com/eniac12/p/5329396.html#s3" target="_blank" rel="noopener">常用排序算法总结</a><br>
<a href="https://github.com/it-interview/easy-job" target="_blank" rel="noopener">2017互联网求职面试知识复习</a></p>
<h1>排序算法</h1>
<table>
<thead>
<tr>
<th>插入排序</th>
<th>选择排序</th>
<th>交换排序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序<br>希尔排序</td>
<td>简单选择排序<br>堆排序</td>
<td>冒泡排序<br>快速排序</td>
<td>归并排序</td>
<td>基数排序</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>是否稳定</th>
<th>平均</th>
<th>最好</th>
<th>最坏</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>稳定</td>
<td>n^2</td>
<td>n</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>n^1.3</td>
<td>n</td>
<td>n^s 1&lt;s&lt;2</td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td>不稳定</td>
<td>n^2</td>
<td>n^2</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>n^2</td>
<td>n</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>nlogn</td>
<td>nlogn</td>
<td>n^2</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>d(n+r)</td>
<td>d(n+r)</td>
<td>d(n+r)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="插入排序-稳定">插入排序 <strong>稳定</strong></h2>
<p>原理：从有序序列中选择合适的位置进行插入</p>
<p>复杂度：最好 - 最坏 - 平均 O(n) - O(n^2) - O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertiontionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> ==a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[i]; <span class="comment">// 暂存</span></span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">			a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+<span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序-缩小增量排序-不稳定">希尔排序(缩小增量排序) <strong>不稳定</strong></h2>
<p>按步长进行分组，组内直接插入，缩小增量再次进行此步骤，增量为1时相当于一次直接插入。</p>
<p>复杂度：最好O(n) - 最坏O(n^s 1&lt;s&lt;2) - 平均O(n^1.3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = a.length/<span class="number">2</span>; d &gt; <span class="number">0</span>; d/=<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 内部直接插入</span></span><br><span class="line">			<span class="keyword">int</span> temp = a[i];</span><br><span class="line">			<span class="keyword">int</span> j = i - d;</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">				a[j+d] = a[j];</span><br><span class="line">				j -= d;</span><br><span class="line">			&#125;</span><br><span class="line">			a[j+d] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-不稳定">选择排序 <strong>不稳定</strong></h2>
<p>原理：每次从无序序列选择一个最小的</p>
<p>复杂度：最好O(n^2) - 最坏O(n^2) - 平均O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[k]) &#123;</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = a[k];</span><br><span class="line">			a[k] = a[i];</span><br><span class="line">			a[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<p>原理：利用堆的特性</p>
<p>复杂度：O(nlogn) [平均 - 最好 - 最坏]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	buildMaxHeap(a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">		a[<span class="number">0</span>] = a[i];</span><br><span class="line">		a[i] = temp;</span><br><span class="line">		adjustHeap(a, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		adjustHeap(a, a.length, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> size, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> right = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> largest = parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; size &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">		largest = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right &lt; size &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">		largest = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent != largest) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[parent];</span><br><span class="line">		a[parent] = a[largest];</span><br><span class="line">		a[largest] = temp;</span><br><span class="line">		adjustHeap(a, size, largest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序-稳定">冒泡排序 <strong>稳定</strong></h2>
<p>原理：相邻两个元素比较大小进行交换，一趟冒泡后会有一个元素到达最终位置</p>
<p>复杂度：最好 - 最坏 - 平均 O(n) - O(n^2) - O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == a || a.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>] = temp;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-不稳定">快速排序 <strong>不稳定</strong></h2>
<p>原理：分治+递归</p>
<p>复杂度：最好O(nlgn) - 最坏O(n^2) - 平均O(nlgn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = partition(a, low, high);</span><br><span class="line">		quickSort(a, low, mid - <span class="number">1</span>);</span><br><span class="line">		quickSort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = a[low];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= pivot) &#123;</span><br><span class="line">			high--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[low] = a[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= pivot) &#123;</span><br><span class="line">			low++;</span><br><span class="line">		&#125;</span><br><span class="line">		a[high] = a[low];</span><br><span class="line">	&#125;</span><br><span class="line">	a[low] = pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选取pivot的方式：固定基准元 随机基准 三数取中</p>
<p>快排的优化：针对随机数组+有序数组+重复数组</p>
<p>1.当待排序序列的长度分割到一定大小后，使用插入排序&lt;三数取中+插入排序&gt;：效率提高一些，但是都解决不了重复数组的问题。</p>
<p>2.在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割<br>
&lt;三数取中+插排+聚集相同元素&gt;</p>
<h2 id="归并排序-稳定">归并排序 <strong>稳定</strong></h2>
<p>原理：两个有序序列的合并，方法：分治 + 递归</p>
<p>复杂度：最好O(nlgn) - 最坏O(nlgn) - 平均O(nlgn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="comment">//左边</span></span><br><span class="line">		mergeSort(a, low, mid);</span><br><span class="line">		<span class="comment">//右边</span></span><br><span class="line">		mergeSort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">		<span class="comment">//有序序列归并</span></span><br><span class="line">		merge(a, low, mid, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 左指针</span></span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="comment">// 右指针</span></span><br><span class="line">	<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 临时数组指针</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">			temp[k++] = a[i++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp[k++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左边剩余</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">		temp[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//右边剩余</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">		temp[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 倒出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; temp.length; t++) &#123;</span><br><span class="line">		a[t + low] = temp[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序-稳定">基数排序 <strong>稳定</strong></h2>
<p>原理：分配加收集</p>
<p>复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 基数</span></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 桶中的数据统计</span></span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line">		<span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按照从低位到高位的顺序执行排序过程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= digit; i++) &#123;</span><br><span class="line">			<span class="comment">// 清空桶中的数据统计</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; radix; j++) &#123;</span><br><span class="line">				count[j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 统计各个桶将要装入的数据个数</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= a.length; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> index = getDigit(a[j], i);</span><br><span class="line">				count[index]++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// count[i]表示第i个桶的右边界索引</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; radix; j++) &#123;</span><br><span class="line">				count[j] = count[j] + count[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将数据依次装入桶中</span></span><br><span class="line">            <span class="comment">// 这里要从右向左扫描，保证排序稳定性</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = a.length-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">int</span> index = getDigit(a[j], i);</span><br><span class="line">				bucket[count[index] - <span class="number">1</span>] = a[j];</span><br><span class="line">				count[index]--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 取出，此时已是对应当前位数有序的表</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">				a[j] = bucket[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取x的第d位的数字，其中最低位d=1</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		String div = <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">while</span> (d &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			div += <span class="string">"0"</span>;</span><br><span class="line">			d--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x/Integer.parseInt(div) % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>排序算法详解</h1>
<p>排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们这里主要讨论内部排序。</p>
<p><img src="/2017/09/28/面试笔试题-排序算法/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.jpg" alt="八大排序算法"></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="简单插入排序">简单插入排序</h3>
<p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p><img src="/2017/09/28/面试笔试题-排序算法/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序过程"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以</p>
<blockquote>
<p>插入排序是<strong>稳定</strong>排序。<br>
时间复杂度<strong>O（n^2)</strong> ,空间复杂度O（1）。<br>
插入排序不适合对于数据量比较大的排序应用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序。时间复杂度O（n^2),空间复杂度O（1），稳定</span></span><br><span class="line"><span class="comment"> * 升序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSorting(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> n=a[i];</span><br><span class="line">		<span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;n)&#123;<span class="comment">//升序。改为a[j]&lt;n则为降序</span></span><br><span class="line">			a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+<span class="number">1</span>]=n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分插入排序">二分插入排序</h3>
<p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序。<br>
当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<p>最差时间复杂度 ---- O(n^2)<br>
最优时间复杂度 ---- O(nlogn)<br>
平均时间复杂度 ---- O(n^2)<br>
所需辅助空间 ------ O(1)</p>
<h3 id="希尔排序">希尔排序</h3>
<p>希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。</p>
<p><img src="/2017/09/28/面试笔试题-排序算法/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 最优复杂度O(n),平均复杂度跟步长选取有关</span></span><br><span class="line"><span class="comment"> * 不稳定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellShorting(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">	<span class="keyword">int</span> n=a.length;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (h &lt;= n)                          <span class="comment">// 生成初始增量</span></span><br><span class="line">		&#123;</span><br><span class="line">				h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">				&#123;</span><br><span class="line">						<span class="keyword">int</span> j = i - h;</span><br><span class="line">						<span class="keyword">int</span> get = a[i];</span><br><span class="line">						<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; get)</span><br><span class="line">						&#123;</span><br><span class="line">								a[j + h] = a[j];</span><br><span class="line">								j = j - h;</span><br><span class="line">						&#125;</span><br><span class="line">						a[j + h] = get;</span><br><span class="line">				&#125;</span><br><span class="line">				h = (h - <span class="number">1</span>) / <span class="number">3</span>;                    <span class="comment">// 递减增量</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序">选择排序</h2>
<h3 id="简单选择排序">简单选择排序</h3>
<p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p>
<p>选择排序的代码如下：</p>
</div><iframe src="/donate/?AliPayQR=/img/alipay.jpg&amp;WeChatQR=/img/wechat.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://sistep.github.io/2017/09/28/面试笔试题-排序算法/" data-id="cjosk6l5e002kadfqnhbh5jtg" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvElEQVR42u3aQY7bQAwEwP3/pxMgpwAb293kjL0ISifDsEYqHcRxk19f8fHrz/H35+/H998/P6v9/vtVjh14eHh4o1t/vtyjz+03G0Zy1j/OxcPDw7vGy5d7Ds4fVv6if371FxY8PDy8j/Ja9uaR4eHh4f0fvLYYPC8DLRUPDw/vp/HyW8ypsy3yJuTFw8PDew9v1gD77Ofr/T08PDy8UVc9GQ44u6U+fLd4eHh4F3h547+NDNqRrNm2O3pAeHh4eBd4yaKzYan2wbXNtuQPAB4eHt5tXoLcjGQl5WEzkhWdi4eHh7fgzRpL7fd5AdiMeeHh4eG9n7fZvOYjBc/PbYtHXTHw8PDw1rw2hki2v0lJyB90uwIeHh7ebV7eQKrzjMWrPy8nRWcPDw8P7ygv31jnLf9ZXDsb7XoxboWHh4d3lDf8Yx+89GcNs015ePg9Hh4e3lFecvkkSJ21wdoV6gEFPDw8vAu85NU/a/MnLbG8MTYbU8DDw8O7wcsXas/KH9Mmun1RtPDw8PDezstbXO1NtCNW+W+ilBoPDw9vwcuD0X1Da8bbr4mHh4d3lld0yeJikP8+j3qT+8TDw8N7D68NcNswoo1681gkj5jx8PDwbvBm8UF7+dn2ut1wP0xc8PDw8A7x9gFBvtndbJFnjTo8PDy827w29223y+3LfXZXDwsDHh4e3iFeHua20cPmttr4+EAbDA8PDy/m5a/v2VBUHsjOCsaLx4qHh4f3Ft6mEdU2zGY3nUQVdSKCh4eHF/Pyow1821vZNNja0oWHh4e3583aS20Ta7bOgcKAh4eHd43XxqZ5cJBHG5sw4kWYi4eHh/chXj6GdaqRlpeNYvQKDw8P7+28aNF4s95GIe2GGw8PD+8er41fk4A1HxfYlJMXq+Hh4eFd4M1ezfnQ1X4jvurd4eHh4Z3k/QbxUO9k+fCAiAAAAABJRU5ErkJggg==" class="article-share-link">Share</a><div class="tags"><a href="/tags/算法/">算法</a><a href="/tags/排序/">排序</a></div><div class="post-nav"><a href="/2017/10/11/面试笔试题-真题/" class="pre">面试笔试题-真题</a><a href="/2017/09/26/北大中文核心期刊/" class="next">北大中文核心期刊</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2146313"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/个人提升/">个人提升</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/小知识/">小知识</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试笔试/">面试笔试</a><span class="category-list-count">12</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Keras/" style="font-size: 15px;">Keras</a> <a href="/tags/Anaconda/" style="font-size: 15px;">Anaconda</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/人工智能/" style="font-size: 15px;">人工智能</a> <a href="/tags/日程/" style="font-size: 15px;">日程</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/zsh/" style="font-size: 15px;">zsh</a> <a href="/tags/时间管理/" style="font-size: 15px;">时间管理</a> <a href="/tags/资料/" style="font-size: 15px;">资料</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/经典题型/" style="font-size: 15px;">经典题型</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/真题/" style="font-size: 15px;">真题</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/健身/" style="font-size: 15px;">健身</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://ferdbi.com/" title="Fern" target="_blank">Fern</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">手与大脑的距离决定了理想与现实的相似度 2018 <a href="/." rel="nofollow">Mr.骑鱼驴</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>