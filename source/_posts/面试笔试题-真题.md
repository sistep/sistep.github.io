---
title: 面试笔试题-真题
date: 2017-10-11 21:24:11
tags:
- 真题
categories:
- 面试笔试
description: 今日头条、美团点评
toc: true
---


# 美团点评

## 给定数位和的最大数
```
对于一个十进制数，它的数位和等于将它各位数字相加的到的和。比如231的数位和是6,3179的数位和是20.
现知道一个十进制数的数位和等于s，且这个数不包含0，且任意相邻的数位是不同的。
比如112或者102都不满足条件。求满足这样条件的最大数是多少

输入：第一行包含一个整数s 1<=s<=42

输出满足条件的最大整数。

```

思路：
1. 位数越多，数字越大，所以每一位数尽可能小。因为相邻两个数不一样，所以每一位数只可能为1或者2。（证：如果有一位数是3，则把它拆成12，新数比原数大一位）
2. 列出n=1——10，观察规律

|1|2|3|4|5|6|7|8|9|10|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|2|21|121|212|2121|12121|21212|212121|1212121|
3. n>2时，n+1对应的数m(n+1)视为n对应的数m(n)修改而来。观察可得如下规律
    - 若m(n)首尾都为1，则m(n+1)为m(n)删掉首部的1，再在末尾加2
    - 若m(n)首尾都为2，则m(n+1)为m(n)尾部加2  
    - 若m(n)首部为2，尾都为1，则m(n+1)为m(n)首部加1

这样就可以将该数字视为字符串处理，使用StringBuilder实现。时间复杂度为O(n)  

```java

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner reader=new Scanner(System.in);
		while(reader.hasNextInt()){
			int n=reader.nextInt();
			System.out.println(maxNum(n));

		}


	}

	public static String maxNum(int n){
		StringBuilder sBuilder=new StringBuilder();
		if(n==1){
			sBuilder.append("1");
		}else if(n==2){
			sBuilder.append("2");
		}else{
			sBuilder.append("21");
			for(int i=3;i<n;i++){
				char head=sBuilder.charAt(0);
				char tail=sBuilder.charAt(sBuilder.length()-1);
				if(head=='1'&&tail=='1'){
					sBuilder=new StringBuilder(sBuilder.subSequence(1, sBuilder.length()));
					sBuilder.append('2');
				}else if(head=='2'&&tail=='2'){
					sBuilder.append('1');
				}else if(head=='2'&&tail=='1'){
					sBuilder.insert(0, '1');
				}
			}
		}


		return sBuilder.toString();


	}

}

```

## 序列移动

```
有一个长度为n的序列，其中的元素分别为1,2,3,...,n。接下来对这个数列进行一些操作。
每一次选一个数，将它从序列中原来的位置去除并放在序列的最前面。求操作后的序列

输入：第一行两个整数n，m，1<=n,m,<=10^5。接下来m行每行包含一个整数k，表示要把k放到序列的最前面。

输出：从前往后输出序列中的每个元素，每个元素占一行。

例如：
输入：
5 3
4
3
5

输出
5
2
4
1
3

```

难点：
1. m个操作中有重复的数的情况
2. 降低时间复杂度上

思路：
如果可以只记录被操作的数和操作的次序，则可能在常数时间复杂度下输出操作后序列。
1. 使用数组记录操作过的数的位置，则可在常数时间复杂度下输出未被操作的数的序列
2. 单独记录已操作过的数，并根据操作顺序存放，则可在常数时间复杂度下输出操作过的数的序列

解法1：
以下算法虽然AC，但是使用了排序，时间复杂度并不是常数级别
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.TreeMap;

public class Main {

	public static void main(String[] args) {
		Scanner reader=new Scanner(System.in);
		while(reader.hasNextInt()){
			int n=reader.nextInt();
			int m=reader.nextInt();
			int[] nums=new int[n];
			int[] heads=new int[n];
			TreeMap<Integer, Integer> tmheads=new TreeMap<>();
			HashMap<Integer, Integer> hmHeads=new HashMap<>();

			for(int i=1;i<=m;i++){
				int index=reader.nextInt()-1;
				nums[index]=-1;
				hmHeads.put(index, i);
			}

			List<Map.Entry<Integer, Integer>> hmlHeads=new ArrayList<Map.Entry<Integer, Integer>>(hmHeads.entrySet());
			Collections.sort(hmlHeads,new Comparator<Map.Entry<Integer, Integer>>() {
				@Override
				public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2) {

					return o2.getValue().compareTo(o1.getValue());
				}

			});

			for(Entry<Integer, Integer> num:hmlHeads){
				System.out.println(num.getKey()+1);
			}

			for(int i=0;i<n;i++){
				if(nums[i]!=-1){
					System.out.println(i+1);
				}
			}
		}

	}

}

```

解法2：
使用长度为n的数组记录未操作的数
使用长度为m的数组记录操作过的数
使用hashmap存放多次操作的数的存放位置
m次操作都可在常数时间内完成
最后只要顺序输出两个数组中需要输出的数
时间复杂度理论上为2(m+n)
```java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int m = scan.nextInt();
		int[] s = new int[n+m];
		for(int i=0;i<n;i++){
			s[m+i] = i+1;
		}
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for(int i=1;i<=m;i++){
			int c = scan.nextInt();
			if(map.containsKey(c)){
				s[m-map.get(c)] = 0;
			}
			map.put(c, i);			
			if(s[m+c-1] == 0){				
				s[m-map.get(c)] = 0;
			}else if(s[m+c-1] != 0){
				s[m+c-1] = 0;
			}
			s[m-i] = c;
		}
		for(int i=0;i<(n+m);i++){
			if(s[i]!=0){
				System.out.println(s[i]);
			}			
		}		
	}
}


```



# 今日头条

## 字符串重叠


```
给定一个字符串s和一个字符串列表的字典，如果字符串s包含字典中的字符串，
就用&lt;b>和&lt;/b>标记，如果不同的子字符串重叠，就需要进行合并。
例如：
input：
s="aaabbbccc"
dict=["aaa","aab","bc"]
output:
"<b>aaabbc</b>c"
```

难点：在于会有位置重叠，需要合并。

思路：匹配dict中字符串在s中的起止位置，存入list中，按起始位置排序。这样只有相邻位置可能出现重叠

重点：
1. 使用`Collections.sort（）`方法排序list
2. 使用`StringBuilder`进行字符串拼接
3. 从后往前插入标记符号，这样前面的字符串起止位置不会变

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Solution {

	public static void main(String[] args) {
		String s="aaabbcc";
		String[] dict={"aaa","aab","bc"};
		Solution so=new Solution();
		System.out.println(so.addBoldTag(s, dict));
	}

  //新建一个类用于存储起止位置。该类需要实现Comparable接口
	public class Tag implements Comparable<Tag>{
		int start;
		int end;
		@Override
		public int compareTo(Tag t) {
			return start-t.start;

		}

	}

	public String addBoldTag(String s,String[] dict){

		List<Tag> list=new ArrayList<>();
		for (String str : dict) {

			int index=s.indexOf(str);
			if(index!=-1){
				Tag tag=new Tag();
				tag.start=index;
				tag.end=index+str.length();
				list.add(tag);
			}

		}

		Collections.sort(list);

		for(int i=0;i<list.size()-1;i++){
			Tag tag1=list.get(i);
			Tag tag2=list.get(i+1);
			if(tag2.start<=tag1.end){
				if(tag2.end>=tag1.end){
					tag1.end=tag2.end;
				}
				list.remove(i+1);
				i--;
			}
		}
    //从后往前插入标志符号
		StringBuilder sb=new StringBuilder(s);
		for(int i=list.size()-1;i>=0;i--){
			Tag aTag=list.get(i);
			sb.insert(aTag.end, "<\\b>");
			sb.insert(aTag.start, "<b>");
		}



		String line=sb.toString();

		return line;
	}

}

```

## 手串颜色
CodeFalling

```
有人向你订购了一条包含n个珠子的手串，每个珠子要么无色，要么涂有若干种颜色。
为了使手串的色彩不单调，
要求手串上的任意一种颜色（不包含无色）在任意连续的m个珠子里至多出现一次（这是一个环形手串）。
手串上的颜色共有c种。
现按顺时针告诉你n个珠子上所包含的颜色分别有哪些。
请判断该手串上有多少种颜色不符合要求。

输入:
第一行为n m c三个数，用空格隔开，接下来的n行每行第一个数num表示第i个珠子有多少种颜色。接下来依次读入num个数字，每个数字表示这个珠子上的一种颜色。

输出：
一个非负整数，表示该手链上有多少种颜色不符合要求。

例如：
输入
5 2 3
3 1 2 3
0
2 2 3
1 2
1 3
输出
2
```


难点：判断窗口需要在一个环上移动

思路：
1. 记录每个颜色出现的位置，用下一次出现的位置与上一次的比较。
2. 遍历两次手串，以覆盖环形的情况

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Shouchuan2 {


	public int n,m,c;
	public static void main(String[] args) throws IOException {
		Shouchuan2 sc2=new Shouchuan2();
		sc2.shouchuancolors();

	}

	public void shouchuancolors() throws IOException{

		BufferedReader bReader=new BufferedReader(new InputStreamReader(System.in));
		String line=bReader.readLine();
		n=Integer.parseInt(line.split(" ")[0]);
		m=Integer.parseInt(line.split(" ")[1]);
		c=Integer.parseInt(line.split(" ")[2]);
		List<List<Integer>> chuan=new ArrayList<>();
		for(int i=0;i<n;i++){
			line=bReader.readLine();
			String[] nums=line.split(" ");
			List<Integer> zhuzi=new ArrayList<>();
			for (String numstr :nums) {
				zhuzi.add(Integer.parseInt(numstr));
			}
			chuan.add(zhuzi);

		}

		int[] colors=new int[c];
		for(int i=0;i<c;i++){
			colors[i]=-1;
		}

		if(n<m){
			System.out.println("0");
			return;
		}


		for (int i=0;i<chuan.size()-1;i++) {
			List<Integer> zhuzi=chuan.get(i);
			for(int j=1;j<zhuzi.size();j++){
				int color=zhuzi.get(j);
				countColor(colors, color, i);
			}
		}



		for(int i=0;i<chuan.size()-1;i++){
			List<Integer> zhuzi=chuan.get(i);
			for(int j=1;j<zhuzi.size();j++){
				int color=zhuzi.get(j);
				countColor(colors, color, i);
			}
		}

		int count=0;
		for (int i : colors) {
			if(i==-2){
				count++;
			}
		}

		System.out.println(count);
	}

	public  void countColor(int[] colors,int color,int i){
		if(colors[color-1]==-2){
			return;
		}
		if(colors[color-1]==-1){
			colors[color-1]=i;
		}else if(colors[color-1]<i){
			if(colors[color-1]-i<m){
				colors[color-1]=-2;
			}else{
				colors[color-1]=i;
			}

		}else if(colors[color-1]>=i){
			if(colors[color-1]+n-i<m){
				colors[color-1]=-2;
			}else{
				colors[color-1]=i;
			}
		}
	}

}

```
